#!/bin/bash
#
# saphana-controller-lib
#
# Description:  library for SAPHanaController
#
##############################################################################
#
# SAPHana
# Author:       Fabian Herschel, November 2013
# Support:      linux@sap.com
# License:      GNU General Public License (GPL)
# Copyright:    (c) 2013,2014 SUSE Linux Products GmbH
# Copyright:    (c) 2015-2023 SUSE LLC
#
# An example usage:
#      See usage() function below for more details...
#
# OCF instance parameters:
#   OCF_RESKEY_SID
#   OCF_RESKEY_InstanceNumber
#   OCF_RESKEY_DIR_EXECUTABLE   (optional, well known directories will be searched by default)
#   OCF_RESKEY_DIR_PROFILE      (optional, well known directories will be searched by default)
#   OCF_RESKEY_INSTANCE_PROFILE (optional, well known directories will be searched by default)
#   OCF_RESKEY_PREFER_SITE_TAKEOVER (optional, default is no)
#   OCF_RESKEY_DUPLICATE_PRIMARY_TIMEOUT (optional, time difference needed between two last-primary-tiemstampe (lpt))
#   OCF_RESKEY_REMOVE_SAP_SOCKETS (optional, default is true)
#
# HANA must support the following commands:
#     hdbnsutil -sr_stateConfiguration (unsure, if this means >= SPS110, SPS111 or SPS10x)
#     hdbnsutil -sr_takeover
#     hdbnsutil -sr_register
#     landscapeHostConfiguration.py
#     systemReplicationStatus.py (>= SPS090)
#
#######################################################################
SAPHanaControllerLibVersion="1.001.10"
#######################################################################
#
# KNOWN PROBLEMS TO BE FIXED:
# P001 - Setup with scale-out and PREFER_SITE_TAKEOVER=true, AUTOMATED_REGISTER=true. If you kill a primary instance it could happen that the primary sets itself to lpt=10 and the secondary will be set to SFAIL and lpt=10 this results in a WAITING4LPA situation. ==> A down/dying primary may never set SFAIL for a secondary!
# P002 - in the swarm non master-nameserver nodes may never set the lpt=date
# P003 - in the swarm non master nodes may NOT do a full master-walk
# P004 - Monitor on "dying" primary and failing systemReplicationStatus script set secondary to SFAIL, so local restart was processed instead of takeover
# DONE PRIO 1: AFTER(!) SAP HANA SPS12 is available we could use hdbnsutil --sr_stateConfiguration

#
# function: super_ocf_log - wrapper function for ocf log in order catch usual logging into super log
# params:   LOG_MESSAGE
# globals:  SAPHanaFilter
function super_ocf_log() {
    local level="$1"
    local message="$2"
    local skip=1
    local mtype=""
    local -u shf="${SAPHanaFilter:-ALLBUTFLOW}"
    # message levels: (dbg)|info|warn|err|error
    # message types:  (ACT|RA|FLOW|DBG|LPA|DEC|DBG2...
    case "$level" in
        debug | dbg | warn | err | error ) skip=0
        ;;
        info )
        case "$shf" in
            ALL)
                skip=0
                ;;
            NONE )
                skip=1
                ;;
            ALLBUTFLOW )
                mtype=${message%% *}
                mtype=${mtype%:}
                [[ "FLOW" == *${mtype}* ]] && skip=1 || skip=0
                ;;
            * ) mtype=${message%% *}
                mtype=${mtype%:}
                [[ ${shf} == *${mtype}* ]] && skip=0 || skip=1
                ;;
        esac
        ;;
    esac
    if [ "$skip" -eq 0 ]; then
        ocf_log "$level" "$message"
    fi
}


#
# function core_init - lightwight variable initialization without SAP HANA interaction
# params: TODO raVersion timeBegin log_attributes
# globals: -
#
function core_init() {
    raVersion="$1"
    timeBegin="$2"
    log_attributes="$3"
    ## GLOBALS
    SID=""
    sidadm=""
    InstanceName=""
    InstanceNr=""
    SAPVIRHOST=""
    DIR_EXECUTABLE=""
    SAPSTARTSRV=""
    SAPCONTROL=""
    DIR_PROFILE=""
    SAPSTARTPROFILE=""
    # Resource Agent Generation
    RAG="2.0"
    SAPHanaFilter='ra-act-dec-lpa'
    super_ocf_log info "RA SAPHanaControllerLibVersion=$SAPHanaControllerLibVersion"
    set +o posix   # disable possix mode of the bash
    if ocf_is_true "$log_attributes"; then
        log_attr_file="/var/log/fhATTRIBUTES"
    else
        log_attr_file="/dev/null"
    fi
    HANA_STATE_PRIMARY=0
    HANA_STATE_SECONDARY=1
    HANA_STATE_STANDALONE=2
    HANA_STATE_DEFECT=3
    HANA_STD_ACTION_TIMEOUT=3600
    #
    # TODO PRIO1: NG - check. if we really could/should initialize such missing variables
    #
    OCF_RESKEY_CRM_meta_timeout="${OCF_RESKEY_CRM_meta_timeout:-3600}"   # cluster should always set these values
    OCF_RESKEY_CRM_meta_clone_max="${OCF_RESKEY_CRM_meta_clone_max:-0}"  # cluster must always set this value
    OCF_RESKEY_CRM_meta_clone_node_max="${OCF_RESKEY_CRM_meta_clone_node_max:-0}"
    OCF_RESKEY_CRM_meta_master_max="${OCF_RESKEY_CRM_meta_master_max:-0}"
    OCF_RESKEY_CRM_meta_master_node_max="${OCF_RESKEY_CRM_meta_master_node_max:-0}"
    # SH=/bin/sh
    log_attributes=false
    #debug_attributes=0   # TODO PRIO3: variable currently unused - remove or use
    return 0
}

function backup_global_and_nameserver() {
    super_ocf_log info "FLOW ${FUNCNAME[0]} ()"
    local rc=0
    local epochseconds=""
    epochseconds="$(date +%s)"  # $EPOCHSECONDS was not available on two lab systems, so fallback to date
    cp "/hana/shared/${SID}/global/hdb/custom/config/global.ini"     "/hana/shared/${SID}/global/hdb/custom/config/global.ini.${epochseconds}"
    cp "/hana/shared/${SID}/global/hdb/custom/config/nameserver.ini" "/hana/shared/${SID}/global/hdb/custom/config/nameserver.ini.${epochseconds}"
    super_ocf_log info "FLOW ${FUNCNAME[0]} rc=$rc"
    return "$rc"
}

#
# function: dequote - filter: remove quotes (") from stdin
# params:   -
# globals:  -
function dequote()
{
    local rc=0; tr -d '"'; return "$rc"
}

# function: version: compare two HANA version strings
function ver_lt() {
    ocf_version_cmp "$1" "$2"
    test "$?" -eq 0 && return 0 || return 1
}

function ver_le() {
    ocf_version_cmp "$1" "$2"
    test "$?" -eq 0 -o "$?" -eq 1 && return 0 || return 1
}

function ver_gt() {
    ocf_version_cmp "$1" "$2"
    test "$?" -eq 2 && return 0 || return 1
}

function ver_ge() {
    ocf_version_cmp "$1" "$2"
    test "$?" -eq 2 -o "$?" -eq 1 && return 0 || return 1
}
#
# function: version: compare two HANA version strings
#
function version() {
    if [ "$#" -eq 3 ]; then
        case "$2" in
            LE | le | "<=" ) ver_le "$1" "$3";;
            LT | lt | "<" ) ver_lt "$1" "$3";;
            GE | ge | ">=" ) ver_ge "$1" "$3";;
            GT | gt | ">" ) ver_gt "$1" "$3";;
            * ) return 1;
        esac
    elif [ $# -ge 5 ]; then
        version "$1" "$2" "$3" && shift 2 && version "$@"
    else
        return 1;
    fi
}

#
# TODO PRIO1: NG - cecl, if we still need that function
# function: remoteHost2remoteNode - convert a SAP remoteHost to the cluster node name
# params:   remoteHost
# globals:  ATTR_NAME_HANA_VHOST[*]
#
function remoteHost2remoteNode()
{
    super_ocf_log info "FLOW ${FUNCNAME[0]} ($*)"
    # local -a clusterNodes=() # TODO PRIO3: variable currently unused - remove or use
    local cl=""
    local vHost=""
    local remoteHost="$1"
    local remoteNode=""
    local rc=1
    for cl in "${otherNodes[@]}"; do
        vHost=$(get_hana_attribute "$cl"  "${ATTR_NAME_HANA_VHOST[@]}" "$cl")
        if [ "$vHost" = "$remoteHost" ]; then # we found the correct node
            remoteNode="$cl"
            rc=0
        fi
    done
    if [ -n "$remoteNode"  ]; then
        echo "$remoteNode"
    fi
    super_ocf_log info "FLOW ${FUNCNAME[0]} rc=$rc"
    return "$rc"
}
#
# function: get_action_timeout
# output:  action timeout
#
# timeOut = max(3600, 95%(actionTimeOut))
#
function get_action_timeout() {
    super_ocf_log info "FLOW ${FUNCNAME[0]} ($*)"
    # $OCF_RESKEY_CRM_meta_timeout is the timeout of the current running action in ms
    local actionTimeOut="$OCF_RESKEY_CRM_meta_timeout"
    local stdTimeOut="$HANA_STD_ACTION_TIMEOUT"
    local actTimeOutPercent=95 # 95% to left 5% for the rest of the resource agent action
    local hanaAction="$1"
    if [ -z "$actionTimeOut" ]; then
        actionTimeOut="$stdTimeOut"
    else
        # actionTimeOut in seconds
        ((actionTimeOut = actionTimeOut/1000))
    fi

    # 95%(actionTimeOut)
    ((timeout = actionTimeOut * actTimeOutPercent/100))
    # max(3600, 95%(actionTimeOut))
    if [ -z "$timeout" ] || [ "$timeout" -lt "$stdTimeOut" ]; then
        timeout="$stdTimeOut"
        super_ocf_log info "DEC: SAP HANA $hanaAction timeout is '$stdTimeOut'"
    else
        super_ocf_log info "DEC: SAP HANA $hanaAction timeout is '$timeout', was default '$stdTimeOut'"
    fi
    super_ocf_log info "FLOW ${FUNCNAME[0]}"
    echo "$timeout"
}

#
# function: is_clone - report, if resource is configured as a clone (also multi-state)
# params:   -
# globals:  OCF_*(r)
# descript: is_clone : find out if we are configured to run in a multi-state configuration
# rc: 0: it is a clone, 1: it is not a clone
#
# DONE: PRIO2: For the first shipment (scale-out) we need to limit the clones to 2
#
function is_clone() {
    super_ocf_log info "FLOW ${FUNCNAME[0]} ($*)"
    local rc=0
    #
    # is a clone config?
    #
    if [ -n "$OCF_RESKEY_CRM_meta_clone_max" ] \
       && [ "$OCF_RESKEY_CRM_meta_clone_max" -gt 0 ]; then
       #
       # yes it is a clone config - check, if its configured well
       #
       # TODO PRIO1: NG - scale-up was also checking '[ "$OCF_RESKEY_CRM_meta_clone_max" -ne 2 ]'
        if [ "$OCF_RESKEY_CRM_meta_clone_node_max" != 1 ] || \
            [ "$OCF_RESKEY_CRM_meta_master_node_max" != 1 ] || \
            [ "$OCF_RESKEY_CRM_meta_master_max" != 1 ]; then
                # scale-up was: super_ocf_log err "ACT: Clone options misconfigured. (expect: clone_max=2,clone_node_max=1,master_node_max=1,master_max=1)"
                super_ocf_log err "ACT: Clone options misconfigured. (expect: clone_node_max=1,master_node_max=1,master_max=1)"
                # TODO PRIO1: NG - check which is the correct return code (scale-up was: OCF_ERR_CONFIGURED)
                exit "$OCF_NOT_RUNNING"
        fi
        rc=0;
    else
        rc=1;
    fi
    super_ocf_log info "FLOW ${FUNCNAME[0]} rc=$rc"
    return "$rc"
}

#
# function: get_hana_attribute
# params:   OBJECT ATTR [STORE]
#           OBJECT could be a node name, a site name or global
# globals:  -
# output:   attribute value
#
function get_hana_attribute()
{
    super_ocf_log info "FLOW ${FUNCNAME[0]} ($*)"
    local rc=0
    local attr_obj=$1
    local attr_name=$2
    local attr_store=${3:-reboot} # DONE: PRIO5 get this (optional) from parameter
    local attr_default=${4:-}
    local dstr
    # local attr_val="" # TODO PRIO3: variable currently unused - remove or use
    dstr=$(date)
    case "$attr_store" in
        reboot | forever )
            if ocf_is_true "$log_attributes"; then
                echo "$dstr: SAPHanaController: crm_attribute -N ${attr_obj} -G -n \"$attr_name\" -l $attr_store -q" >> "$log_attr_file"
            fi
            crm_attribute -N "${attr_obj}" -G -n "$attr_name" -l "$attr_store" -q -d "$attr_default" 2>>"$log_attr_file"; rc="$?"
            ;;
        props )
            if ocf_is_true "$log_attributes"; then
                echo "$dstr: SAPHanaController: crm_attribute -G -n \"$attr_name\" -t crm_config -q" >> "$log_attr_file"
            fi
            crm_attribute -G -n "$attr_name" -t crm_config -q -d "$attr_default" 2>>"$log_attr_file"; rc="$?"
            ;;
    esac
    super_ocf_log info "FLOW ${FUNCNAME[0]} rc=$rc"
    return "$rc"
}

#
# function: set_hana_attribute - set the multi-state status of a node
# params:   OBJECT VALUE ATTR [STORE [DEFAULT]]
#           OBJECT could be a node name, a site name or global
# globals:  -
#
function set_hana_attribute()
{
    super_ocf_log info "FLOW ${FUNCNAME[0]} ($*)"
    local attr_obj=$1
    local attr_value=$2
    local attr_name=$3
    local attr_store=${4:-reboot} # DONE: PRIO5 get this (optional) from parameter
    local attr_default=${5:-}
    local rc=1
    local attr_old=""
    attr_old=$(get_hana_attribute "$attr_obj" "$attr_name" "$attr_store" "$attr_default"); get_rc="$?"
    if [ "$attr_old" != "$attr_value" ]; then
        super_ocf_log debug "DBG: SET attribute $attr_name for node ${attr_obj} to ${attr_value} former ($attr_old) get_rc=$get_rc "
        dstr=$(date)
        case "$attr_store" in
            reboot | forever )
                if ocf_is_true "$log_attributes"; then
                    echo "$dstr: SAPHanaController: crm_attribute -N $attr_obj -v \"$attr_value\" -n \"$attr_name\" -l $attr_store" >> "$log_attr_file"
                fi
                crm_attribute -N "$attr_obj" -v "$attr_value" -n "$attr_name" -l "$attr_store" 2>>"$log_attr_file"; rc="$?"
                ;;
            props )
                if ocf_is_true "$log_attributes"; then
                    echo "$dstr: SAPHanaController: crm_attribute -v \"$attr_value\" -n \"$attr_name\" -t crm_config -s SAPHanaSR" >> "$log_attr_file"
                fi
                crm_attribute -v "$attr_value" -n "$attr_name" -t crm_config  -s SAPHanaSR 2>>"$log_attr_file"; rc="$?"
                ;;
        esac
    else
        super_ocf_log debug "DBG: LET attribute $attr_name for node ${attr_obj} still be ${attr_value}"
        rc=0
    fi
    super_ocf_log info "FLOW ${FUNCNAME[0]} rc=$rc"
    return "$rc"
}

# set_hana_site_attribute <site> <value> <ATTRIBUTE-TEMPLATE>
function set_hana_site_attribute()
{
    super_ocf_log info "FLOW ${FUNCNAME[0]} ($*)"
    local rc=0
    local attr_obj="$1"
    local attr_value=$2
    local attr_name="${3}_${attr_obj}"
    local attr_store=${4:-props} # site attributes are always props, non node attributes
    local attr_default=${5:-}
    set_hana_attribute "$attr_obj" "$attr_value" "$attr_name" "$attr_store" "$attr_default"
    super_ocf_log info "FLOW ${FUNCNAME[0]} rc=$rc"
    return 0
}

# get_hana_site_attribute <site> <ATTRIBUTE-TEMPLATE>
function get_hana_site_attribute()
{
    super_ocf_log info "FLOW ${FUNCNAME[0]} ($*)"
    local rc=0
    local attr_obj="$1"
    local attr_name="${2}_${attr_obj}"
    local attr_store=${3:-props} # site attributes are always props, non node attributes
    local attr_default=${4:-}
    get_hana_attribute "$attr_obj" "$attr_name" "$attr_store" "$attr_default"
    super_ocf_log info "FLOW ${FUNCNAME[0]} rc=$rc"
    return 0
}

#
# function: assert - quickly go out of here with minimal error/return code handling and log
# params:   MESSAGE
# globals:  OCF_*(r)
#
function assert() {
    super_ocf_log info "FLOW ${FUNCNAME[0]} ($*)"
    local err_msg=$1
    # local default_exit="$OCF_NOT_RUNNING" # TODO PRIO3: variable currently unused - remove or use
    # TODO PRIO3: NG - decide, if assert in normal actions (not probe) needs to return OCF_ERR_CONFIGURED
    # for now we use the scale-out solution; check with upstream documentation, if OCF_NOT_RUNNING is better reaction here
    #if ocf_is_probe; then
    #    default_exit="$OCF_NOT_RUNNING"
    #else
    #    # TODO PRIO3: NG - scale-up was OCF_ERR_CONFIGURED, scale-out OCF_NOT_RUNNING - which is the better option?
    #    default_exit="$OCF_NOT_RUNNING"
    #fi
    if [ "$ACTION" = "stop" ]; then
        cleanup_instance
        exit "$OCF_SUCCESS"
    fi
    super_ocf_log err "ACT: $err_msg"
    exit "$OCF_NOT_RUNNING"
}

#
# function: set_crm_master - set the crm master score of the local or remote node
# params:   SCORE  [NODE]
# globals:  HA_SBIN_DIR(r), OCF_RESOURCE_INSTANCE(r)
#
function set_crm_master()
{
    super_ocf_log info "FLOW ${FUNCNAME[0]} ($*)"
    local rc=0
    local score=0
    local node=""
    if [ -n "$1" ]; then
        score=$1
    fi
    if [ -n "$2" ]; then
        node="-N $2"
    fi
    # DONE: PRIO2: Only adjust master if value is really different (try to check that)
    oldscore=$("${HA_SBIN_DIR}/crm_master" "$node" -G -q -l reboot)
    if [ "$oldscore" != "$score" ]; then
       dstr=$(date)
       if ocf_is_true "$log_attributes"; then
           echo "$dstr: SAPHanaController: crm_master $node -v $score -l reboot " >> "$log_attr_file"
       fi
       super_ocf_log debug "DBG: SET crm master: $node $score (old: $oldscore)"
       "${HA_SBIN_DIR}/crm_master" "$node" -v "$score" -l reboot; rc="$?"
    else
       super_ocf_log debug "DBG: LET crm master: $score"
       rc=0
    fi
    return "$rc"
}

#
# function: scoring_crm_master - score instance due to role and sync match (table SCORING_TABLE)
# params:   NODE_ROLES NODE_SYNC_STATUS
# globals:  SCORING_TABLE[@],
#
function scoring_crm_master()
{
    super_ocf_log info "FLOW ${FUNCNAME[0]} ($*)"
    local hana_roles="$1"
    local hana_sync="$2"
    local myScore=""
    local scoring_rule
    local lssPattern srrPattern rolePattern syncPattern myScore patternDescription fullRolePattern
    for scoring_rule in "${SCORING_TABLE[@]}"; do
        # parts are: lss-pattern srr-pattern role-pattern sync-pattern description
        read -r lssPattern srrPattern rolePattern syncPattern myScore patternDescription <<< "$scoring_rule"
        fullRolePattern="$lssPattern:$srrPattern:$rolePattern"
        if [[ "${hana_roles}" =~ $fullRolePattern ]] && [[ "${hana_sync}" =~ $syncPattern ]]; then
              super_ocf_log info "DEC: scoring_crm_master: roles($hana_roles) are matching pattern ($fullRolePattern)"
              super_ocf_log info "DEC: scoring_crm_master: sync($hana_sync) is matching syncPattern ($syncPattern)"
              super_ocf_log info "DEC: scoring_crm_master: set score $myScore ($patternDescription)"
              break;  # end scanning, best rule already found
        fi
    done
    super_ocf_log debug "DBG: scoring_crm_master adjust score $myScore"
    # Do not score, if we did not found our role/sync at this moment - bsc#919925
    if [ -n "$myScore" ]; then
        set_crm_master "$myScore"
    fi
}

#
# function: get_crm_master - get the crm master score of the local node
# params:   -
# globals:  HA_SBIN_DIR(r)
#
function get_crm_master()
{
  super_ocf_log info "FLOW ${FUNCNAME[0]} ()"
  local rc=0
   "${HA_SBIN_DIR}/crm_master" -G -q -l reboot; rc=$?
   return "$rc"
}

#
# function: HANA_CALL
# params:   timeout-in-seconds cmd-line
# globals:  sid(r), SID(r), InstanceName(r)
#
function HANA_CALL()
{
    #
    # TODO: PRIO 5: remove 'su - ${sidadm} later, when SAP HANA resoled issue with
    #       root-user-called hdbnsutil -sr_state (which creates root-owned shared memory file in /var/lib/hdb/SID/shmgrp)
    #       would hdbnsutil -sr_stateConfiguration also create such a shared memory file?
    # TODO: PRIO 5: Maybe make "su" optional by a parameter
    local timeOut=0
    local rc=0
    local use_su=1 # Default to be changed later (see TODO above)
    local pre_cmd_type=""
    local cmd=""
    local pre_script=""
    local output=""
    while [ $# -gt 0 ]; do
        case "$1" in
            --timeout ) timeOut=$2; shift;;
            --use-su  ) use_su=1;;
            --cmd ) shift; cmd="$*"; break;;
        esac
        shift
    done

    if [ "$use_su" -eq 1 ]; then
        pre_cmd_type="su"
        [[ "$cmd" == python* ]] && pre_script="cd $DIR_EXECUTABLE/python_support" || pre_script='true'
    else
        # as root user we need the library path to the SAP kernel to be able to call sapcontrol
        # check, if we already added DIR_EXECUTABLE at the beginning of LD_LIBRARY_PATH
        if [ "${LD_LIBRARY_PATH%%*:}" != "$DIR_EXECUTABLE" ]
        then
            MY_LD_LIBRARY_PATH="$DIR_EXECUTABLE${LD_LIBRARY_PATH:+:}$LD_LIBRARY_PATH"
        fi
        pre_cmd_type="bash"
        pre_script="LD_LIBRARY_PATH=$MY_LD_LIBRARY_PATH; export LD_LIBRARY_PATH"
    fi
    case "$timeOut" in
        0 | inf )
                  case "$pre_cmd_type" in
                      bash )
                            output=$(bash -c "$pre_script; $cmd"); rc="$?"
                            ;;
                      su )
                            output=$(su - "${sid}adm" -c "$pre_script; $cmd"); rc="$?"
                            ;;
                  esac
                  ;;
        *       )
                  errExt=$(date '+%s%N')_${sid}adm
                  su_err_log=/tmp/HANA_CALL_SU_RA_${errExt}
                  cmd_out_log=/tmp/HANA_CALL_CMD_RA_OUT_${errExt}
                  cmd_err_log=/tmp/HANA_CALL_CMD_RA_${errExt}

                  case "$pre_cmd_type" in
                      bash )
                            output=$(timeout --foreground -s 9 "$timeOut" bash -c "($pre_script; timeout -s 9 $timeOut $cmd > $cmd_out_log) >& $cmd_err_log" 2>"$su_err_log"); rc="$?"
                            ;;
                      su )
                            output=$(timeout --foreground -s 9 "$timeOut" su - "${sid}adm" -c "($pre_script; timeout -s 9 $timeOut $cmd > $cmd_out_log) >& $cmd_err_log" 2>"$su_err_log"); rc="$?"
                            ;;
                  esac
                  output=$(if [ -f "$cmd_out_log" ]; then cat "$cmd_out_log"; rm -f "$cmd_out_log"; fi)
                  suErr=$(if [ -f "$su_err_log" ]; then cat "$su_err_log"; rm -f "$su_err_log"; else echo "NA"; fi)
                  cmdErr=$(if [ -f "$cmd_err_log" ]; then cat "$cmd_err_log"; rm -f "$cmd_err_log"; else echo "NA"; fi)
                  super_ocf_log debug "DBG: RA ==== action HANA_CALL (cmd is '$cmd', rc is '$rc', stderr from su is '$suErr', stderr from cmd is '$cmdErr') ===="
                  # on rc=1 - retry to improve the behavior in AD environments
                  # fh 20230127 deactivate this part. rc=1 could also be the valid rc of the called command
                  # TODO PRIO2: NG - to improve handling of su-errors we need to catch this errors and differ them from the cmd rc
                  #if [ "$rc" -eq 1 ]; then
                  #    super_ocf_log warn "RA: HANA_CALL stderr from command '$pre_cmd_type' is '$suErr', stderr from command '$cmd' is '$cmdErr'"
                  #    if [ "$cmdErr" == "NA" ]; then
                  #        # seems something was going wrong with the 'pre_cmd_type' (su)
                  #        super_ocf_log warn "DEC: HANA_CALL returned '1' for command '$pre_cmd_type'. Retry once."
                  #        output=$(timeout --foreground -s 9 "$timeOut" $pre_cmd "$pre_script; timeout -s 9 $timeOut $cmd"); rc="$?"
                  #    fi
                  #fi
                 ;;
    esac
    super_ocf_log debug "DBG: HANA_CALL '$cmd' rc=$rc output=$output"
    echo "$output"
    return "$rc";
}

#
# function get_SRHOOK_plain
# fetches site specific Hook SR status ONLY
# globals: ATTR_NAME_HANA_SITE_SRHOOK[@](r)
# locals:  ATTR[@], my_sync, get_sr_name
#
function get_SRHOOK_plain()
{
    local my_sync
    local get_sr_name="$1"
    get_hana_site_attribute "$get_sr_name" "${ATTR_NAME_HANA_SITE_SRHOOK[@]}"
    return 0
}

#
# function get_SRHOOK
# fetches site specific Hook SR status or (as fallback) the polling-attribute
# params: site-name site-host
# globals: ATTR_NAME_HANA_SITE_SRHOOK[@](r), ATTR_NAME_HANA_SITE_SYNC_STATUS[@](r)
# locals:  my_sync, get_sr_name
#
function get_SRHOOK()
{
    local my_sync
    local get_sr_name="$1"
    # We assume for NG, that SR attributes are site specific
    my_sync=$(get_hana_site_attribute "$get_sr_name" "${ATTR_NAME_HANA_SITE_SRHOOK[@]}")
    #
    # fallback to polling attribute, if hook attribute is unset or SWAIT
    #
    if [ -z "$my_sync" ] || [ "$my_sync" = "SWAIT" ]; then
        super_ocf_log info "RA: hook attribute is empty or 'SWAIT': SRHOOK=$my_sync"
        my_sync=$(get_hana_site_attribute "$get_sr_name" "${ATTR_NAME_HANA_SITE_SYNC_STATUS[@]}")
        super_ocf_log info "RA: fallback to polling attribute SRHOOK=$my_sync"
    fi
    # still unable to determine any SR attribute, so be pessimistic
    if [ -z "$my_sync" ]; then
        my_sync="SFAIL"
    fi
    super_ocf_log info "DEC: Finally get_SRHOOK()=$my_sync"
    echo "$my_sync"
    return 0
}

#
# function set_SRHOOK - sets the site specific Hook SR status
# params: site-name, value
# globals: ATTR_NAME_HANA_SITE_SRHOOK[@](r), ATTR_NAME_HANA_SYNC_STATUS[@](r)
# locals:  ATTR[@], my_sync, get_sr_name
# SAPHanaSR ANGI already uses multi-target aware SR Hook attribute there is not global fallback attribute
#
function set_SRHOOK()
{
    local my_sync old_sync
    local get_sr_name="$1"
    local value="$2"
    set_hana_site_attribute "$get_sr_name" "$value" "${ATTR_NAME_HANA_SITE_SRHOOK[@]}"
    return 0
}

#
# function set_SRHOOK_PRIM - sets the site specific Hook SR status
# params: site-name, value
# globals: ATTR_NAME_HANA_SITE_SRHOOK[@](r), ATTR_NAME_HANA_SYNC_STATUS[@](r)
# locals:  ATTR[@], my_sync, get_sr_name
# SAPHanaSR Scale-Up already uses multi-target aware SR Hook attribute there is not global fallback attribute
#
function set_SRHOOK_PRIM()
{
    local lastSrHook
    local lastRemSrHook
    # to be backward compatible only set the site attribute, if the local or remote site attribute is already used (set) in the past
    lastSrHook=$(get_SRHOOK_plain "$sr_name")
    lastRemSrHook=$(get_SRHOOK_plain "$remSR_name")
    if [ -n "${lastSrHook}${lastRemSrHook}" ]; then
        # reset srHook attribute to PRIM as we found either local or remote srHook attribute
        set_SRHOOK "$sr_name" "PRIM"
    fi
}

function saphana_init_scoring_tables() {
    # SCORING_TABLE_PREFERRED_SITE_TAKEOVER_SU is the default table, if topology PreferSiteTakeover are not detected. So the table also covers some basic checks for scale-out
    # format of the scoring table lines:
    # <lss> <primary-secondary> <configured-mns-role>[:<actice-mns-role>]  <sync-status>   <score> ['<score-description>']
    SCORING_TABLE_PREFERRED_SITE_TAKEOVER_SU=(
       "[234]   P [^:]*:master         .*       150             'primary - running, active master nameserver role'"
       "[234]   P master               .*       140             'primary - running, configured master nameserver role (failover candidate)'"
       "[015-9] P [^:]*:master         .*        90             'primary - not running, but active master nameserver role '"
       "[0-9]   P [^:]*:slave          .*        60             'primary - any running status, slave master nameserver role (should not happen for ScaleUp)'"
       "[234]   P [^:]*:[?:-]          .*         0             'primary - running, but nameserver role not detected'"
       "[015-9] P [^:]*:[?:-]          .*        -1             'primary - not running and nameserver role not detected'"
       "[234]   S [^:]*:master         SOK      100             'secondary - running, active master nameserver role, in sync'"
       "[234]   S [^:]*:master         PRIM     100             'secondary - running, active master nameserver role, already marked as PRIMary'"
       "[015-9] S [^:]*:master         SOK       80             'secondary - not running, but active master nameserver role and in sync'"
       "[0-9]   S [^:]*:master         SFAIL    -INFINITY       'secondary - any running status, active master nameserver role, not in sync (exclude for promote)'"
       "[0-9]   S [^:]*:slave          SOK       10             'secondary - any running status, slave master nameserver role and in sync (should not happen for ScaleUp)'"
       "[0-9]   S [^:]*:slave          SFAIL    -INFINITY       'secondary - any running status, slave master nameserver role and not in sync (should not happen for ScaleUp)'"
       "[234]   S [^:]*:[?:-]          .*         0             'secondary - running, but nameserver role not detected'"
       "[015-9] S [^:]*:[?:-]          .*        -1             'secondary - not running and nameserver role not detected'"
       ".*                             .*        -1             'any case, not catched before'"
    )
    SCORING_TABLE_PREFERRED_LOCAL_RESTART_SU=(
       "[0-9]   P [^:]*:master         .*     150               'primary - any running status, active master nameserver role'"
       "[0-9]   P [^:]*:.*             .*     140               'primary - any running status, any other active namesrever role (even still not detected)'"
       "[0-9]   S [^:]*:master         SOK    100               'secondary - any running status, active master nameserver role, in sync'"
       "[0-9]   S [^:]*:master         PRIM   100               'secondary - any running status, active master nameserver role, already marked as PRIMary'"
       "[0-9]   S [^:]*:master         SFAIL  -INFINITY         'secondary - any running status, active master nameserver role, not in sync'"
       "[0-9]   S [^:]*:slave          SOK     10               'secondary - any running status, slave master nameserver role and in sync (should not happen for ScaleUp)'"
       "[0-9]   S [^:]*:slave          SFAIL  -INFINITY         'secondary - any running status, slave master nameserver role and not in sync (should not happen for ScaleUp)'"
       "[234]   S [^:]*:[?:-]          .*      -1               'secondary - running, but nameserver role not detected'"
       "[015-9] S [^:]*:[?:-]          .*      -1               'secondary - not running and nameserver role not detected'"
       ".*                             .*      -1               'any case, not catched before'"
    )
    SCORING_TABLE_PREFERRED_NEVER_SU=(
       "[234]   P [^:]*:master         .*     150               'primary - running, active master nameserver role'"
       "[015-9] P [^:]*:master         .*      90               'primary - not running, but active master nameserver role'"
       "[0-9]   P [^:]*:.*             .*     -INFINITY         'primary - any running status, any other active namesrever role (even still not detected)'"
       "[0-9]   S [^:]*:.*             .*     -INFINITY         'secondary - any running status, any other active namesrever role (even still not detected)'"
       ".*                             .*     -INFINITY         'any case, not catched before'"
    )
    SCORING_TABLE_PREFERRED_SITE_TAKEOVER_SO=(
       "[234]   P master[123]:master            .*          150 'not described yet'"
       "[234]   P master[123]                   .*          140 'not described yet'"
       "[234]   P master[123]:slave:.*:standby  .*          115 'not described yet'"
       "[234]   P master[123]:slave             .*          110 'not described yet'"
       "[015]   P master[123]:                  .*           70 'not described yet'"
       "[0-9]   P master[123]:*:standby         .*           60 'not described yet'"
       "[0-9]   P slave:                        .*       -10000 'not described yet'"
       "[234]   S master[123]:master            SOK         100 'not described yet'"
       "[234]   S master[123]:slave             SOK          80 'not described yet'"
       "[015]   S master[123]:                  SOK          70 'not described yet'"
       "[0-9]   S master[124]:*:standby         SFAIL    -22100 'not described yet'"
       "[0-9]   S slave:                        SOK      -12200 'not described yet'"
       "[0-9]   S slave:                        SFAIL    -22200 'not described yet'"
       "[0-9]   S                               .*       -32300 'not described yet'"
       ".*                                      .*       -33333 'not described yet'"
    )
    SCORING_TABLE_PREFERRED_LOCAL_RESTART_SO=(
       "[0-9]   P [^:]*:master           .*          150 'not described yet'"
       "[0-9]   P [^:]*:slave            .*          140 'not described yet'"
       "[0-9]   P [^:]*:\?               .*            0 'not described yet'"
       "[0-9]   P [^:]*:-                .*            0 'not described yet'"
       "[0-9]   S [^:]*:master           SOK         100 'not described yet'"
       "[0-9]   S [^:]*:master           SFAIL -INFINITY 'not described yet'"
       "[0-9]   S [^:]*:slave            SOK          10 'not described yet'"
       "[0-9]   S [^:]*:slave            SFAIL -INFINITY 'not described yet'"
       "[0-9]   S [^:]*:\?               .*            0 'not described yet'"
       "[0-9]   S [^:]*:-                .*            0 'not described yet'"
       ".*                               .*           -1 'not described yet'"
    )
    SCORING_TABLE_PREFERRED_NEVER_SO=(
       "[234]   P master[123]:master     .*          150 'not described yet'"
       "[234]   P master[123]:slave      .*          110 'not described yet'"
       "[015]   P master[123]:           .*           70 'not described yet'"
       "[0-9]   P master[123]:*:standby  .*           60 'not described yet'"
       "[0-9]   P slave:                 .*       -10000 'not described yet'"
       "[0-9]   S [^:]*:*:              SNA    -INFINITY 'not described yet'"
       "[0-9]   S [^:]*:*:               .*    -INFINITY 'not described yet'"
       ".*                               .*    -INFINITY 'not described yet'"
    )
}

function saphana_init_attribute_definitions()
{
    # TODO PRIO1: NG - check which atributes to keep and which attributes to delete
    # TODO PRIO1: NG - sort attributes to node, site, global area
    #
    # node specific attributes
    #
    # attributes used to control the update from single-target replication
    # to mutli-target replication.
    # node specific, set, if the NewResourceAgent is running on the system
    # contains the resource agent generation ($RAG)
    ATTR_NAME_HANA_GRA=("hana_${sid}_gra" "forever")
    # attribute containing the current running srHook generation
    ATTR_NAME_HANA_SRHOOK_GEN=("hana_${sid}_gsh" "reboot")
    ATTR_NAME_HANA_CLONE_STATE=("hana_${sid}_clone_state" "reboot") # UNKNOWN?, DEMOTED, PROMOTED
    # ATTR_NAME_HANA_REMOTEHOST=("hana_${sid}_remoteHost" "forever")  # unused variable, remove or use
    ATTR_NAME_HANA_SITE=("hana_${sid}_site" "forever")
    ATTR_NAME_HANA_ROLES=("hana_${sid}_roles" "reboot")
    ATTR_NAME_HANA_VHOST=("hana_${sid}_vhost" "forever")
    # ATTR_NAME_HANA_STATUS=("hana_${sid}_status" "reboot") # unused variable, remove or use
    # ATTR_NAME_HANA_VERSION=("hana_${sid}_version" "reboot") # unused variable, remove or use
    ATTR_NAME_HANA_SRACTION=("hana_${sid}_sra" "reboot") # Marks, if cluster in a phase requesting  a takeover (T) or registration (R)
    ATTR_NAME_HANA_SRACTION_HISTORY=("hana_${sid}_srah" "reboot") # Marks, if cluster in a phase requesting  a takeover (T) or registration (R)
    #
    # new "central" attributes
    #
    # TODO PRIO1: NG - decide which attributes to be moved to site-specific
    # new "central" attribute, containing the summarized status, if all
    # cluster nodes are already updated to the new RA or if there are still
    # nodes left running the old RA version
    # expected value "ok" - "nok", if there still old RAs running in the cluster
    ATTR_NAME_HANA_UPD_STATE=("hana_${sid}_glob_upd" "props")
    # attribut showing, if migration from global to site specific hook should
    # be done - customer choice
    ATTR_NAME_HANA_multiTargetSupport=("hana_${sid}_glob_mts" "props")
    #
    ATTR_NAME_HANA_PRIM=("hana_${sid}_glob_prim" "props")                        # SITE
    ATTR_NAME_HANA_SEC=("hana_${sid}_glob_sec" "props")                          # SITE
    # TODO PRIO1: NG - ATTR_NAME_HANA_SRMODE2 to be moved to site specific
    ATTR_NAME_HANA_SRMODE2=("hana_${sid}_glob_srmode" "props" "sync")            # sync syncmem async
    #
    # For MULTI-TARGET we need a site-specific attribute not a global one
    # but for compatibility we need to recognize the old global attribute too
    # TODO PRIO1: NG - ATTR_NAME_HANA_GLOB_SRHOOK needs to be ATTR_NAME_HANA_SITE_SRHOOK
    ATTR_NAME_HANA_GLOB_SRHOOK=("hana_${sid}_glob_srHook" "props")                    # external triggered SOK, SFAIL
    ATTR_NAME_HANA_FILTER=("hana_${sid}_glob_filter" "props" "ra-act-dec-lpa")
    ATTR_NAME_HANA_TOPOLOGY=("hana_${sid}_glob_topology" "props" "")   # ScaleUp ScaleOut
    #
    # SITE based attributes
    #
    # TODO PRIO1: NG - check which attributes to keep and which attributes to move from other spaces to site specific
    # scale-out and scale-up now use LPA as site specific attribute
    ATTR_NAME_HANA_SITE_LPA=("hana_${sid}_site_lpt" "props")
    # ATTR_NAME_HANA_SITE_OPERATION_MODE=("hana_${sid}_site_op_mode" "props" "logreplay") # TODO PRIO2: NG - reuse this variable
    ATTR_NAME_HANA_SITE_SRHOOK=("hana_${sid}_site_srHook" "props")                    # external triggered SOK, SFAIL
    ATTR_NAME_HANA_SITE_LSS=("hana_${sid}_site_lss" "props")
    ATTR_NAME_HANA_SITE_SRR=("hana_${sid}_site_srr" "props")
    ATTR_NAME_HANA_SITE_MNS=("hana_${sid}_site_mns" "props")
    ATTR_NAME_HANA_SITE_SYNC_STATUS=("hana_${sid}_site_srPoll" "props")       # polling attribute SOK, SFAIL
}

function saphana_init_get_remote_site()
{
    # TODO PRIO2: NG allow multiple remote sites later
    #
    #
    # get remote site name
    # PRIO1: WHAT TO DO, IF remSite could not be fetched?
    # TODO: PRIO1: NG - Do not overwrite already found remSite, if next node does not provide this value
    # TODO: PRIO9: For later releases we might add the feature to differ between other remote Sites. Currently we only allow two SR sites of
    #              one SAP HANA Database in the same cluster. So only e.g. WALLDORF and ROT and not WALLDORF, ROT and NUSSLOCH.
    #              This limits us to only have sites A => B inside of the cluster and completely "ignore" site C
    #
    for clN in "${otherNodes[@]}"; do
	    nodeSite=$(get_hana_attribute "$clN" "${ATTR_NAME_HANA_SITE[@]}")
        super_ocf_log info "TOP: clN=$clN, nodeSite=$nodeSite"
        if [[ -n "$nodeSite" && "$nodeSite" != "$site" ]]; then
            remSite="$nodeSite"
            remSR_name="${remSite%%:*}"
            # remSR_id="${remSite#*:}"  # TODO PRIO2: NG - do we need the site id (number)?
        fi
    done
    # It's always the master name server of the remote site which is really relevant, so we do not need any longer each nodes remoteHost
    # TODO PRIO1: NG - function to set/get site specific attributes
    # get_hana_site_attribute <site> <ATTRIBUTE-TEMPLATE> <???>
    # set_hana_site_attribute <site> <value> <ATTRIBUTE-TEMPLATE> <???>

    rem_mns=$(get_hana_site_attribute "$remSR_name" "${ATTR_NAME_HANA_SITE_MNS[@]}")
    remoteHost="$rem_mns"
    super_ocf_log debug "DBG: remoteHost is $remoteHost"
    remoteNode="$rem_mns"
}

function saphana_init_get_hana_version()
{
    local ges_ver
    ges_ver=$(grep -s -m1 -oP 'fullversion: \K.+(?= Build)' "/usr/sap/$SID/$InstanceName/exe/manifest")
    #fallback
    [[ -z ${ges_ver:-} ]] && ges_ver=$(HANA_CALL --timeout 10 --cmd "HDB version" | tr -d " " | awk -F: '$1 == "version" {print $2}')
    #Version xx.yy.zzz
    [[ ${ges_ver} =~ [0-9]+(\.[0-9]+){2} ]] && hdbver=${BASH_REMATCH[0]}
    super_ocf_log info "DEC: SAP HANA version  $hdbver detected"
}

function saphana_init_sap_commands()
{
    # TODO PRIO2: NG also set --sapcontrol=1 here
    hdbState="hdbnsutil -sr_stateConfiguration"
    #hdbMap="hdbnsutil -sr_stateHostMapping"   # TODO PRIO2: NG - do we need hdbMap again?
    local standbyFilter=""
    if [ "$ACTION" = "stop" ]; then
       standbyFilter="--standbyFilter=off"
    fi
}

#
# function: cluster_get_other_nodes - list all 'other' cluster nodes, but not the local node
# params: node-name-to-be-filtered-out
# globals: -
#
function cluster_get_other_nodes()
{
    local NODENAME="$1"
    local -a NODELIST
    local ne=""
    local ch=""
    # TODO PRIO1: NG - check this new code here
    #             lines are expected to have format <number><blank><nodename><blank><status>
    #             example: "1 grimsel01 member"
    mapfile -t NODELIST < <(crm_node -l)    # syntax < <(...) is intended
    for ne in "${NODELIST[@]}";
    do
       ne="${ne// /:}"  # replace blank by colon for better reg-ex parsing
       if [[ "$ne" =~ ^([0-9]+):([^:]+) ]]; then
           ch="${BASH_REMATCH[2]}"
           if [[ "$ch" != "${NODENAME}" ]]; then
               echo "$ch";
           fi
       fi
    done
    return 0
}

# chk4systemdsupport - check, if SAP systemd support is available
# check for the existence of the SAP SID+Instance related unit file
# rc=0 - sap instance unit file exists
# rc=1 - sap instance unit file does NOT exist
function chk4systemdsupport() {
    super_ocf_log info "FLOW ${FUNCNAME[0]}"
    local systemd_unit_name="SAP${SID}_${InstanceNr}.service"
    local rc=1
    if [ -x "$SYSTEMCTL" ]; then
        if [ -f "/etc/systemd/system/$systemd_unit_name" ]; then
            rc=0
        elif "$SYSTEMCTL" list-unit-files | \
            awk '$1 == service { found=1 } END { if (! found) {exit 1}}' service="${systemd_unit_name}"; then
            rc=0
        else
            rc=1
        fi
    fi
    return "$rc"
}

#
# handle_unix_domain_sockets
# params: -
# globals: OCF_RESKEY_REMOVE_SAP_SOCKETS
#
function handle_unix_domain_sockets() {
    super_ocf_log info "FLOW ${FUNCNAME[0]}"

    if ocf_is_true "$RemoveSAPSockets"; then
        # previous and new default handling
        # removing the unix domain socket files as they might have
        # wrong permissions or ownership
        # they will be recreated by sapstartsrv during next start
        rm -f /tmp/.sapstream5"${InstanceNr}"13
        rm -f /tmp/.sapstream5"${InstanceNr}"14
    else
        # try to change permission and ownership of the unix domain socket files
        for sockFile in /tmp/.sapstream5"${InstanceNr}"13 /tmp/.sapstream5"${InstanceNr}"14; do
            sockError=false
            if [ -S "$sockFile" ]; then
                if ! chown "${sid}"adm "$sockFile" > /dev/null 2>&1; then
                    sockError=true
                fi
                if ! chgrp sapsys "$sockFile" > /dev/null 2>&1; then
                    sockError=true
                fi
                if chmod 700 "$sockFile" > /dev/null 2>&1; then
                    sockError=true
                fi
            else
                if [ -f "$sockFile" ]; then
                    super_ocf_log error "RA: file '$sockFile' still exists, but is NO longer a socket."
                    super_ocf_log info "DEC: remove file '$sockFile' to give sapstartsrv a chance to create it the right way during next start"
                    sockError=true
                else
                    super_ocf_log info "RA: file '$sockFile' not found. Nothing to do, let sapstartsrv create a new one during start"
                fi
            fi
            if ocf_is_true "$sockError"; then
                # fallback - if there are Errors, remove unix domain socket as
                # last resort
                rm -f "$sockFile"
            fi
        done
    fi
}

#
# function: check_sapstartsrv - check for sapstartsrv - optional start
# params:   -
# globals:  DIR_PROFILE(w), SAPSTARTPROFILE(r), SAPCONTROL(r), SID(r), InstanceName(r), InstanceNr(r), OCF_*(r)
# check_sapstartsrv : Before using sapcontrol we make sure that the sapstartsrv is running.
#
function check_sapstartsrv() {
    super_ocf_log info "FLOW ${FUNCNAME[0]} ()"
    local restart=0
    local runninginst=""
    local rc="$OCF_SUCCESS"
    local output=""
    if chk4systemdsupport; then
        # use systemd to control sapstartsrv
        local systemd_unit_name="SAP${SID}_${InstanceNr}.service"

        if "$SYSTEMCTL" is-active --quiet "$systemd_unit_name"; then
            super_ocf_log info "ACT: systemd service $systemd_unit_name is active"
        else
            super_ocf_log warn "ACT: systemd service $systemd_unit_name is not active, it will be started using systemd"
            # use start, because restart does also stop sap instance
            "$SYSTEMCTL" start "$systemd_unit_name" >/dev/null 2>&1; src=$?
            if [ "$src" -ne 0 ]; then
                super_ocf_log error "ACT: error during start of systemd unit ${systemd_unit_name}!"
                rc="$OCF_ERR_GENERIC"
                ocf_is_probe && rc="$OCF_NOT_RUNNING"
            fi
        fi
    else
        # no SAP systemd unit available, continue with old code...
        if [ ! -S "/tmp/.sapstream5${InstanceNr}13" ]; then
            super_ocf_log warn "ACT: sapstartsrv is not running for instance $SID-$InstanceName (no UDS), it will be started now"
            restart=1
        else
            if output=$("$SAPCONTROL" -nr "$InstanceNr" -function ParameterValue INSTANCE_NAME -format script)
            then
                runninginst=$(echo "$output" | grep '^0 : ' | cut -d' ' -f3)
                if [ "$runninginst" != "$InstanceName" ]
                then
                    super_ocf_log warn "ACT: sapstartsrv is running for instance $runninginst, that service will be killed"
                    restart=1
                else
                    if ! output=$("$SAPCONTROL" -nr "$InstanceNr" -function AccessCheck Start)
                    then
                        super_ocf_log warn "ACT: FAILED - sapcontrol -nr $InstanceNr -function AccessCheck Start ($(ls -ld1 "/tmp/.sapstream5${InstanceNr}13"))"
                        super_ocf_log warn "ACT: sapstartsrv will be restarted to try to solve this situation, otherwise please check sapstsartsrv setup (SAP Note 927637)"
                        restart=1
                    fi
                fi
            else
                super_ocf_log warn "ACT: sapstartsrv is not running for instance $SID-$InstanceName, it will be started now"
                restart=1
            fi
        fi
        if [ -z "$runninginst" ]; then runninginst="$InstanceName"; fi
        if [ "$restart" -eq 1 ]
        then
            if [ -d "/usr/sap/$SID/SYS/profile/" ]
            then
                DIR_PROFILE="/usr/sap/$SID/SYS/profile"
            else
                assert "Expected /usr/sap/$SID/SYS/profile/ to be a directory, please set DIR_PROFILE parameter!"
            fi
            [ ! -r "$SAPSTARTPROFILE" ] && assert "Expected $SAPSTARTPROFILE to be the instance START profile, please set INSTANCE_PROFILE parameter!"
            pkill -9 -f "sapstartsrv.*$runninginst"

            handle_unix_domain_sockets
            (
              export PATH="$DIR_EXECUTABLE${PATH:+:}$PATH"
              export LD_LIBRARY_PATH="$DIR_EXECUTABLE${LD_LIBRARY_PATH:+:}$LD_LIBRARY_PATH"
              "$SAPSTARTSRV" pf="$SAPSTARTPROFILE" -D -u "$sidadm"
            )
            # now make sure the daemon has been started and is able to respond
            local srvrc=1
            while [[ "$srvrc" == "1" ]] && pgrep -f "sapstartsrv.*$runninginst"
            do
                sleep 1
                "$SAPCONTROL" -nr "$InstanceNr" -function GetProcessList > /dev/null 2>&1
                srvrc=$?
            done
            if [ "$srvrc" -ne 1 ]
            then
                super_ocf_log info "ACT: sapstartsrv for instance $SID-$InstanceName was restarted!"
                rc="$OCF_SUCCESS"
            else
                super_ocf_log error "ACT: sapstartsrv for instance $SID-$InstanceName could not be started!"
                rc="$OCF_ERR_GENERIC"
                ocf_is_probe && rc="$OCF_NOT_RUNNING"
            fi
        fi
    fi
    return "$rc"
}

#
# function: cleanup_instance - remove resources from a crashed instance
# params:   -
# globals:  -
#
function cleanup_instance() {
  super_ocf_log info "FLOW ${FUNCNAME[0]} ()"
  local rc=0
  # TODO: PRIO5: Check, if we need HANA cleanup procedure (processes, ipc obj, pid files); Currently not needed
  super_ocf_log debug "DBG: cleanup_instance currently not implemented"
  rc=0
  super_ocf_log info "FLOW ${FUNCNAME[0]} rc=$rc"
}

#
# function: check_for_primary - check if local SAP HANA is configured as primary
# params:   -
# globals:  HANA_STATE_PRIMARY(r), HANA_STATE_SECONDARY(r), HANA_STATE_DEFECT(r)
#
function check_for_primary() {
    super_ocf_log info "FLOW ${FUNCNAME[0]} ()"
    local rc="$HANA_STATE_DEFECT"
    local ini_mode=""
    local chkMethod=""
    for chkMethod in  hU hU hU gP; do
       case "$chkMethod" in
           gP )
                # fallback for 'hdbnsutil' failing 3 times.
                local gpKeys=""
                gpKeys=$(echo --key=global.ini/system_replication/{actual_mode,mode})
                # TODO PRIO2: use sap commands from saphana_init_sap_commands()
                node_full_status=$(HANA_CALL --timeout "$HANA_CALL_TIMEOUT" --cmd "python getParameter.py $gpKeys --sapcontrol=1" 2>&1 | awk -F/ 'BEGIN {out=0} /^SAPCONTROL-OK: <begin>/ { out=1 } /^SAPCONTROL-OK: <end>/ { out=0 } /=/ {if (out==1) {print $3} }')
                # first try to get the value of 'actual_mode' from the global.ini
                ini_mode=$(echo "$node_full_status" | awk -F= '$1=="actual_mode" {print $2}')
                # if 'actual_mode' is not available, fallback to 'mode'
                if [ -z "$ini_mode" ]; then
                    ini_mode=$(echo "$node_full_status" | awk -F= '$1=="mode" {print $2}')
                fi
                node_status="$ini_mode"
                super_ocf_log info "ACT: Using getParameter.py as fallback - node_status=$node_status"
                ;;
           hU | * )
                # TODO PRIO2: use sap commands from saphana_init_sap_commands()
                node_full_status=$(HANA_CALL --timeout "$HANA_CALL_TIMEOUT" --cmd "$hdbState" 2>/dev/null )
                node_status=$(echo "$node_full_status" | awk '$1=="mode:" {print $2}')
                super_ocf_log debug "DBG: check_for_primary: node_status=$node_status"
                ;;
       esac
       case "$node_status" in
           primary )
               rc="$HANA_STATE_PRIMARY"
               break;;
           syncmem | sync | async )
               rc="$HANA_STATE_SECONDARY"
               break;;
           none ) # have seen that mode on second side BEFORE we registered it as replica
               rc="$HANA_STATE_STANDALONE"
               break;;
           * )
               super_ocf_log err "ACT: check_for_primary:  we didn't expect node_status to be: <$node_status>"
               dump=$( echo "$node_status" | hexdump -C );
               super_ocf_log err "ACT: check_for_primary:  we didn't expect node_status to be: DUMP <$dump>"
               # TODO PRIO2: Limit the runtime of hdbnsutil and use getParameter.py as fallback
               # SAP_CALL
               super_ocf_log debug "DEC: check_for_primary: loop=$i: node_status=$node_status"
               # TODO: PRIO1: NG - Maybe we need to keep the old value for P/S/N, if hdbnsutil just crashes
       esac;
       # TODO PRIO1: NG - decide if to use sleep 20 (scale-out) or 2 (scale-up)
       sleep 20
    done
    super_ocf_log info "FLOW ${FUNCNAME[0]} rc=$rc"
    return "$rc"
}

# analyze_hana_sync_statusSQL removed

#
# function: get_hana_landscape_status - figure out hana landscape status
# params:   -
# globals:  sidadm(r), DIR_EXECUTABLE(r), hana_LSS_Out(w)
#
function get_hana_landscape_status()
{
    super_ocf_log info "FLOW ${FUNCNAME[0]} ()"
    local rc=0
    hana_LSS_Out=$(HANA_CALL --timeout "$HANA_CALL_TIMEOUT" --cmd "python landscapeHostConfiguration.py --sapcontrol=1" 2>/dev/null); rc=$?
    if [ "$rc" -eq 124 ]; then
        # TODO: PRIO 1: Check, if we should loop here like 'for i in 1 2 3 ...' ?
        # landscape timeout
        super_ocf_log warn "RA: landscapeHostConfiguration.py TIMEOUT after $HANA_CALL_TIMEOUT seconds"
        sleep 20
        hana_LSS_Out=$(HANA_CALL --timeout "$HANA_CALL_TIMEOUT" --cmd "python landscapeHostConfiguration.py --sapcontrol=1" 2>/dev/null); rc=$?
        if [ "$rc" -eq 124 ]; then
           super_ocf_log warn "RA: landscapeHostConfiguration.py second TIMEOUT after $HANA_CALL_TIMEOUT seconds"
           # TODO PRIO2: How to handle still hanging lss - current solution is to say "FATAL"
           rc=0
        fi
    fi
    return "$rc";
}

#
# check_for_primary_master
# checks for a "remote" primary master
# params: -
# globals: ATTR_NAME_HANA_SITE_SRR(r), ATTR_NAME_HANA_SITE_LSS(r), remSR_name(r)
# rc: 0 for available primary (lss is 3 or 4); 1 otherwise
#
function check_for_primary_master()
{
    super_ocf_log info "FLOW ${FUNCNAME[0]} ()"
    local rc=1
    #
    # get landscape-status and sr-role from "remote" site
    #
    rem_lss=$(get_hana_site_attribute "$remSR_name" "${ATTR_NAME_HANA_SITE_LSS[@]}")
    rem_srr=$(get_hana_site_attribute "$remSR_name" "${ATTR_NAME_HANA_SITE_SRR[@]}")
    case "$rem_lss:$rem_srr" in
        3:P | 4:P ) rc=0;;
        * ) rc=1;;
    esac
    super_ocf_log info "FLOW ${FUNCNAME[0]} rc=$rc"
    return "$rc"
}

#
# wait_for_primary_master: wait some time till a running primary master is shown in attributes
# params: optional: loop count - currently time in 10s waiting loop
# globals: -
#
function wait_for_primary_master()
{
    local wait=1
    local rc=1
    local loops=${1:-0}
    local count=0
    super_ocf_log info "FLOW ${FUNCNAME[0]} ($*)"
    #
    # hana_ndb_roles=primary:master1:master:worker:master
    #
    while [ "$wait" == 1 ]; do
        if check_for_primary_master; then
           wait=0
           rc=0
        else
           if [ "$loops" -gt 0 ]; then
              (( count++ ))
              if [ "$count" -gt "$loops" ]; then
                 wait=0
                 rc=1
              fi
           fi
           sleep 10
        fi
    done
    super_ocf_log info "FLOW ${FUNCNAME[0]} rc=$rc"
    return "$rc"
}

#
# function: lpa_get_lpt - get lpt from cluster
# params:   SITE
# output:   LPT
# rc:       rc=0: OK, rc=1: InternalERROR, rc=2: ERROR
# globals:  ATTR_NAME_HANA_SITE_LPA_*,
#
function lpa_get_lpt() {
    super_ocf_log info "FLOW ${FUNCNAME[0]} ($*)"
    local rc=1
    local mysite=$1
    local lpt=""
    super_ocf_log debug "DBG: ${FUNCNAME[0]} get_hana_attribute X " "${ATTR_NAME_HANA_SITE_LPA[@]}"
    lpt=$(get_hana_site_attribute "${mysite}" "${ATTR_NAME_HANA_SITE_LPA[@]}")
    if [ -n "$lpt" ]; then
        rc=0
        echo "$lpt"
    else
        rc=2
    fi
    super_ocf_log info "FLOW ${FUNCNAME[0]} rc=$rc"
    return "$rc"
}

#
# function: lpa_set_lpt - set lpt in cluster
# params:   LPT [site]
# globals:  ATTR_NAME_HANA_SITE_LPA(r), NODENAME(r),
# rc:       rc=0: OK, rc=1: InternalERROR, rc=2: ERROR
#
function lpa_set_lpt() {
    super_ocf_log info "FLOW ${FUNCNAME[0]} ($*)"
    local rc=1
    #local crm_rc=1
    local lpt=$1
    local clpt=-1
    local mysite=$2
    if [ -n "$mysite" ]; then
        set_hana_site_attribute "${mysite}" "$lpt" "${ATTR_NAME_HANA_SITE_LPA[@]}" || super_ocf_log error "LPA: setting cluster attribute failed"
        clpt=$(lpa_get_lpt "$mysite")
        if [ "$lpt" != "$clpt" ]; then
            super_ocf_log error "LPA: lpa_set_lpt failed for lpt=$lpt and mysite=$mysite"
            rc=2
        else
            rc=0
        fi
    else
       super_ocf_log info "DEC: lpa_set_lpt - ignore changing lpt due to lost site name"
    fi
    super_ocf_log info "FLOW ${FUNCNAME[0]} rc=$rc"
    return "$rc"
}

#
# function: lpa_pull_lpt - fetch lpt from file
# params:   -
# globals:  LPA_DIRECTORY(r), sid, NODENAME
# output:   LPT
# rc:       rc=0: OK, rc=1: InternalERROR, rc=2: ERROR
#
function lpa_pull_lpt() {
    super_ocf_log info "FLOW ${FUNCNAME[0]} ()"
    local rc=1
    local lpt=-1
    local lpa_file="$LPA_DIRECTORY/lpa_${sid}_${NODENAME}"
    #
    # only fetch the first word of the first line as lpt
    #
    mapfile <"$lpa_file";
    lpt="${MAPFILE[0]%% *}" # only catch first word of first line
    if [ -n "$lpt" ]; then
        echo "$lpt"
        rc=0
    else
        rc=2
    fi
    super_ocf_log info "FLOW ${FUNCNAME[0]} rc=$rc"
    return "$rc"
}

#
# function: lpa_push_lpt - put lpt to file
# params:   LPT
# globals:  LPA_DIRECTORY(r), sid, NODENAME
# output:   --
# rc:       rc=0: OK, rc=1: InternalERROR, rc=2: ERROR
#
function lpa_push_lpt() {
    super_ocf_log info "FLOW ${FUNCNAME[0]} ($*)"
    local lpt=$1
    local clpt=-1
    local rc=1
    local lpa_file="$LPA_DIRECTORY/lpa_${sid}_${NODENAME}"
    #
    mkdir -p "$LPA_DIRECTORY"
    echo "$lpt" > "$lpa_file"
    clpt=$(lpa_pull_lpt); lpt_rc=$?
    if [[ "$clpt" != "$lpt" || "$lpt_rc" != 0 ]]; then
        rc=2
    else
        rc=0
    fi
    super_ocf_log info "FLOW ${FUNCNAME[0]} rc=$rc"
    return "$rc"
}

#
# function: lpa_init_lpt - initialize local lpt, if needed
# params:   HANA_STATE
# globals:  HANA_STATE_*(r), LPA_DIRECTORY(r), sid(r), NODENAME(r),
# lpa_init_lpt
#
# Returncodes:
#    rc=0: OK,  rc=1 InternalERROR,  rc=2: ERROR
#
# Initializing (if NO local LPT-file):
#    SECONDARY sets to 0
#    PRIMARY   sets to 1
#
function lpa_init_lpt() {
    super_ocf_log info "FLOW ${FUNCNAME[0]} ($*)"
    local rc=1
    local LPTloc=-1
    local LPTrem=-1
    local hana_state=$1
    local lpa_file="$LPA_DIRECTORY/lpa_${sid}_${NODENAME}"
    mkdir -p "$LPA_DIRECTORY"
    LPTloc=$(lpa_get_lpt "${sr_name}") || LPTloc=$(lpa_pull_lpt) || \
        if   [ "$hana_state" == "$HANA_STATE_PRIMARY" ];  then    # Initialize for Primary
            # init primary
            LPTloc=20
            lpa_push_lpt "20"; rc=$?
        elif [ "$hana_state" == "$HANA_STATE_SECONDARY" ]; then   # Initialize for Secondary
            # init secondary
            LPTloc=10
            lpa_push_lpt "10"; rc=$?
        else
            rc=2
        fi
    lpa_set_lpt "$LPTloc" "$sr_name"
    super_ocf_log info "FLOW ${FUNCNAME[0]} rc=$rc"
    return "$rc"
}

#
# function: lpa_check_lpt_status - start a hana clone instance
# params:   -
# globals:  DUPLICATE_PRIMARY_TIMEOUT, NODENAME, remoteNode
# lpa_check_lpt_status
#
# Returncodes:
#    0: start
#    1: register    (then start)
#    2: wait4gab    (WAIT4LPA - Older LPA needs to expire)
#    3: wait4other  (WAIT4LPA - Remote LPA needs to be announced)
#    4: lpa internal error
#
# Initializing (if NO local LPT-file):
#    SECONDARY sets to 10
#    PRIMARY   sets to 20
#
#    LPRlocal OR LPTremote ARE real lpt (>1000)
#        THEN:
#            Bigger LPR wins, if delta-gab is OK
#               LPTlocal >> LPTremote ===> rc=0 (start)
#               LPTRemote >> LPTlocal ===> rc=1 (register)
#            Stalemate in all other cases ==> STALEMATE-HANDLING ===> rc=2 (wait4gab)
#    LPRlocal AND LPTremote ARE NOT real lpt (<=1000)
#        THEN:
#            Bigger LPT wins
#               LPTlocal > LPTremote ===> rc=0 (start)
#               LPTRemote > LPTlocal ===> rc=1 (register)
#            Stalemate in all other cases ==> STALEMATE-HANDLING ===> rc=2 (wait4gab)
#    LPTRemote is not initialized or node/site not known to the cluster (0)
#    TODO: PRIO1: NG - Need to introduce a return-code 3 for remote sides lpa not ready
#        THEN:
#            WAIT ==> LOST REMOTE HANDLING ===> rc=3 (wait4other)
#
function lpa_check_lpt_status() {
    super_ocf_log info "FLOW ${FUNCNAME[0]} ()"
    local rc=4
    local LPTloc=-1
    local LPTrem=-1
    local LPTMark=1000
    local delta=0
    #
    # First GET LPT from ATTR-FILE-DEFAULT
    #
    LPTloc=$(lpa_get_lpt "$sr_name"); lparc=$?   # ATTR
    if [ "$lparc" != 0 ]; then
        # as a fallback try to fetch the value from external status file
        LPTloc=$(lpa_pull_lpt);                 # FILE
        lparc=$?
        if [[ -z "$LPTloc" || "$LPTloc" != -1 || "$lparc" != 0 ]]; then
            # last option - try to initialize as PRIMARY
            lpa_push_lpt 20
            lpa_set_lpt  20 "$sr_name"
            LPTloc=20                           # DEFAULT
        fi
    fi
    LPTrem=$(lpa_get_lpt "$remSR_name"); lparc="$?"
    super_ocf_log info "LPA: LPTloc=$LPTloc LPTrem=$LPTrem"
    if [ "$lparc" -ne 0 ]; then
        # LPT of the other node could not be evaluated - LPA says WAIT
        super_ocf_log debug "DBG: LPA: LPTloc=$LPTloc, LPTrem undefined ==> WAIT"
        rc=3
    else
        super_ocf_log debug "DBG: LPA: LPTloc ($LPTloc) LPTrem ($LPTrem) delta ($delta)"
        if [[ "$LPTloc" -lt "$LPTMark" && "$LPTrem" -lt "$LPTMark" ]]; then
           delta=0   # both lpts are not a real timestamp so just take the greater one
        else
           delta="$DUPLICATE_PRIMARY_TIMEOUT"   # at least one of the lpts is a real timestamp so include delta-gap
        fi
        if (( delta < LPTloc - LPTrem )); then
            # We are the winner - LPA says STARTUP
            super_ocf_log debug "DBG: LPA: LPTloc wins $LPTloc > $LPTrem + $delta ==> START"
            rc=0
        elif (( delta < LPTrem - LPTloc )); then
            if ocf_is_true "$AUTOMATED_REGISTER" ; then
                # The other one has won - LPA says REGISTER
                super_ocf_log debug "DBG: LPA: LPTrem wins $LPTrem > $LPTloc + $delta ==> REGISTER"
                rc=1
            else
                super_ocf_log debug "DBG: LPA: LPTrem wins $LPTrem > $LPTloc + $delta BUT AUTOMATED_REGISTER='false' ==> WAIT"
                rc=2
            fi
        else
            super_ocf_log debug "DBG: LPA: Difference between LPTloc and LPTrem is less than delta ($delta) ==> WAIT"
            # TODO: PRIO3: ADD STALEMATE-HANDLING HERE; currently admin should set one of the lpa to 20
            rc=2
        fi
    fi
    super_ocf_log info "FLOW ${FUNCNAME[0]} rc=$rc"
    return "$rc"
}

# function: master_walk - find master node(s)
# params:   -
# globals:  the_master(w), masters[@](w), nr_site_node(w), nr_site_worker(w), nr_site_standby(w)
function master_walk() {
    #
    # TODO: PRIO1: NG - EXCLUDE NON ONLINE CLUSTER NODES (offline/unclean/standby/maintenance)
    #
    # * crm node list se03 is online, se01 is standby+maintenance, se02 is offline
    # se01group1:
    #       standby: on
    #       maintenance: on
    # se02group1: (offline)
    # se03group1:
    # * crm_node -l (corosync)
    # 1084752138 se01group1 member
    # 1084752148 se02group1 lost
    # 1084752154 se03group1 member
    #
    # ==> First exclude non-members (maybe done already) by
    #       'list of nodes | grep member'
    # ==> then query the attributes 'standby' and 'maintenance
    # OR:
    # look at the scores:
    #
    # master_walk now also counts available nodes (same site) in the
    super_ocf_log info "FLOW ${FUNCNAME[0]} ($*)"

    local active_master="" master1="" master2="" master3=""
    local nSite="" nodeRole=""
    local best_cold_master="" rest=""
    local standbyFilter=1
    nr_site_node=0     # is counting any node reporting a role like 'worker' or 'standby'
    nr_site_worker=0   # is counting 'configured' worker nodes
    nr_site_standby=0  # is counting 'configured' standby nodes
    while [ $# -gt 0 ]; do
        case "$1" in
            --standbyFilter=off ) standbyFilter=0;;
        esac
        shift
    done
    #
    # 2:S:master1:slave:worker:standby  MAINZ
    # 4:P:master1:master:worker:master  KOELN
    # 4:P:master2:slave:worker:slave    KOELN
    # 4:P:slave:slave:worker:slave      KOELN
    super_ocf_log debug "DBG: master walk"
    # walk over all known cluster nodes
    for node in "$NODENAME" "${otherNodes[@]}"; do
        super_ocf_log debug "DBG: master walk node $node"
        nSite="$(get_hana_attribute "${node}" "${ATTR_NAME_HANA_SITE[@]}")"
        if [ "$site" = "$nSite" ]; then
            # node of same site found
            nStdBy="$(crm_attribute -N "${node}" -n standby     -G -l forever -q -d off)"
            nMaint="$(crm_attribute -N "${node}" -n maintenance -G -l forever -q -d off)"
            if [ "$nMaint" = "on" ]; then
                super_ocf_log debug "DBG: Filter node by cluster node maintenance mode"
            elif [[ "$nStdBy" = "on" && "$standbyFilter" = "1" ]]; then
                super_ocf_log debug "DBG: Filter node by cluster node standby mode"
            else
                nodeRole="$(get_hana_attribute "${node}" "${ATTR_NAME_HANA_ROLES[@]}")"
                super_ocf_log debug "DBG: site $site $nodeRole"
                case "$nodeRole" in
                    master1:master:*  ) master1="$node"; active_master="$node"
                        super_ocf_log debug "DBG: roles $nodeRole match master1:master:*"
                        ;;
                    master2:master:*  ) master2="$node"; active_master="$node"
                        super_ocf_log debug "DBG: roles $nodeRole match master2:master:*"
                        ;;
                    master3:master:*  ) master3="$node"; active_master="$node"
                        super_ocf_log debug "DBG: roles $nodeRole match master3:master:*"
                        ;;
                    master1:*       ) master1="$node";
                        super_ocf_log debug "DBG: roles $nodeRole match master1:*"
                        ;;
                    master2:*       ) master2="$node";
                        super_ocf_log debug "DBG: roles $nodeRole match master2:*"
                        ;;
                    master3:*       ) master3="$node";
                        super_ocf_log debug "DBG: roles $nodeRole match master3:*"
                        ;;
                    *:shtdown:*       )
                        super_ocf_log debug "DBG: roles $nodeRole ignore node (down)" # TODO PRIO2: NG - do we need to change to *:-:* ?
                        ;;
                    * )
                        super_ocf_log debug "DBG: roles $nodeRole NO match"
                    ;;
                esac
                case "$nodeRole" in
                    *:*:worker )  (( nr_site_worker++ ))
                                  (( nr_site_node++ ))
                                  ;;
                    *:*:standby ) (( nr_site_standby++ ))
                              (( nr_site_node++ ))
                              ;;
                esac
                super_ocf_log debug "DBG: $site: $nodeRole"
            fi
        fi
    done
    if [ -z "$active_master" ]; then
        masters=( "$master1" "$master2" "$master3" )
        best_cold_master="${masters[0]}"
        the_master="$best_cold_master"
    else
        the_master="$active_master"
    fi
    #
    # set MNS local-site attribute
    #
    set_hana_site_attribute "$sr_name" "$the_master" "${ATTR_NAME_HANA_SITE_MNS[@]}"

    super_ocf_log info "DEC: ===> master_walk: priorities for site $site master1=$master1 master2=$master2 master3=$master3 ==> active_master=$active_master best_cold_master=$best_cold_master"
    super_ocf_log info "DEC: ===> master_walk: the_master=$the_master;"
    super_ocf_log info "FLOW ${FUNCNAME[0]} the_master=$the_master rc=0"
}

# function: is_active_nameserver_slave
# params:   -
# rc:       0: yes its an active nameserver slave (running)
#           2: yes it is a configured but lost slave  # TODO PRIO2: NG - rc2 seems to got lost
#           1: else
# globals:
#
# true, if the node has an active (runnig) master nameserver slave role
#
function is_active_nameserver_slave()
{
    super_ocf_log info "FLOW ${FUNCNAME[0]} ()"
    local rc=1 nodeRole=""
    nodeRole="$(get_hana_attribute "${NODENAME}" "${ATTR_NAME_HANA_ROLES[@]}")"
    case "$nodeRole" in
        slave:slave )
            # configured as slave and actual role also detected as slave
            rc=0
            ;;
        * )
            rc=1
        ;;
    esac
    super_ocf_log info "DEC: is_active_nameserver_slave rc=$rc"
    super_ocf_log info "FLOW ${FUNCNAME[0]} rc=$rc"
    return "$rc"
}

# function: is_lost_nameserver_slave
# params:   -
# rc:       0: yes it is a configured but lost slave
#           1: else
# globals:  ATTR_NAME_HANA_ROLES[@], NODENAME
#
# true, if the node has an active (runnig) master nameserver slave role
#
function is_lost_nameserver_slave()
{
    # TODO PRIO2: NG - check this new code carefully
    super_ocf_log info "FLOW ${FUNCNAME[0]} ()"
    local rc=1 nodeRole=""
    nodeRole="$(get_hana_attribute "${NODENAME}" "${ATTR_NAME_HANA_ROLES[@]}")"
    case "$nodeRole" in
        slave:* )
            # configured as slave but actual role could not be figured out - treat as is_lost_nameserver_slave
            rc=0
            ;;
        * )
            rc=1
            ;;
    esac
    super_ocf_log info "DEC: is_lost_nameserver_slave ($nodeRole) rc=$rc"
    super_ocf_log info "FLOW ${FUNCNAME[0]} rc=$rc"
    return "$rc"
}

# function: is_master_nameserver
# params:   -
# rc:       0: yes its a master nameserver
#           1: else
# globals:  ATTR_NAME_HANA_ROLES[@], NODENAME
#
# true, if the node has an active or configured master nameserver role
#
function is_master_nameserver()
{
    super_ocf_log info "FLOW ${FUNCNAME[0]} ()"
    local rc=1 nodeRole=""
    nodeRole="$(get_hana_attribute "${NODENAME}" "${ATTR_NAME_HANA_ROLES[@]}")"
    # IFS=: read -a nodeFields <<<"$with_colon"
    # nFields=( ${nRole//:/ } )
    case "$nodeRole" in
        master[123]:master:* )
           rc=0
           ;;
        master[123]:* )
           rc=0
           ;;
        * )
           rc=1
           ;;
    esac
    super_ocf_log info "DEC: is_master_nameserver  rc=$rc"
    super_ocf_log info "FLOW ${FUNCNAME[0]} rc=$rc"
    return "$rc"
}

# function: is_the_master_nameserver
# params:   -
# rc:       0: yes, local node is THE master nameserver
#           1: else
# globals:
function is_the_master_nameserver()
{
    super_ocf_log info "FLOW ${FUNCNAME[0]} ()"
    local rc=1
    # TODO PRIO1: NG - always true for scale-up, for scale-out we need to check the_master
    if [ "$the_master" = "$NODENAME" ]; then
        rc=0
    fi
    super_ocf_log info "FLOW ${FUNCNAME[0]} rc=$rc"
    return "$rc"
}

function recover_site_attributes_from_file()
{
    local srHookAttributeFile="$1"
    local site
    local -a mapLines
    local srAttr srValue

    if [ -f "$srHookAttributeFile" ]; then
        #
        # need to read attribute from the file
        #
        mapfile -t mapLines <"$srHookAttributeFile"
        for mapLine in "${mapLines[@]}"; do
            srAttr="${mapLine%%=*}"   # cut-off right side of a = b
            srAttr="${srAttr// /}"    # attribute must not contain blanks
            srValue="${mapLine#*=}"   # cut-off left side of a = b
            srValue="${srValue## }"   # cut-off leading blanks in value
            srValue="${srValue%% }"   # cut-off trailing blanks in value
            srValue="${srValue#\'}"   # cut-off leading single quote
            srValue="${srValue%\'}"   # cut-off closing single quote
            # TODO PRIO3: NG - check this new code-part
            case "$srAttr" in
                hana_${sid}_site_srHook_* )
                    #
                    # get site name from site attribute-name
                    #
                    site="${srAttr#hana_"${sid}"_site_srHook_}"
                    super_ocf_log info "DEC: srHookAttribute file found - recover lost SAP HA/DR event for site=$site ($srAttr=$srValue)"
                    #
                    # DONE: PRIO0 - add check for srATTR name here
                    #
                    case "$srValue" in
                    SOK )
                          super_ocf_log info "DEC: recover attributes from file $srHookAttributeFile - calling set_SRHOOK $site SOK"
                          set_SRHOOK "$site" "SOK"
                          ;;
                    SFAIL )
                          super_ocf_log info "DEC: recover attributes from file $srHookAttributeFile - calling set_SRHOOK $site SFAIL"
                          set_SRHOOK "$site" "SFAIL"
                          ;;
                    * )
                          super_ocf_log info "DEC: failed recover attributes from file $srHookAttributeFile - Unknown value <<$srValue>>"
                          ;;
                    esac
                    ;;
            esac
        done
        rm "$srHookAttributeFile"
    fi
}

# set ts=4 sw=4 sts=4 et
