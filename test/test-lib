#!/bin/bash
#
# test-lib
#
########
#

set -u

declare -a sapHanaSr

function init() {
    verbose=0
    while [ $# -gt 0 ]; do
        case "$1" in
            --node=* ) node="${1#*=}";;
            --testCase=* ) testCase="${1#*=}";;
            --testFile=* ) testFile="${1#*=}";;
            --verbose ) verbose=1;; 
        esac
        shift
    done
    storeSAPHanaSR "$node"
    loadTests "$testFile"
    #
    # get primary site and host
    #
    pSite="$(search4getObject 'Sites/.*/srr="P"')"
    pHost="$(search4getObject 'Hosts/.*/site="'"$pSite"'"')"
    sSite="$(search4getObject 'Sites/.*/srr="S"')"
    sHost="$(search4getObject 'Hosts/.*/site="'"$sSite"'"')"
    message "INIT(): pHost=$pHost, pSite=$pSite, sHost=$sHost, sSite=$sSite"
}

function message() {
    echo "$(date +'%Y-%m-%d %T') $*"
}

function storeSAPHanaSR() {
    # purpose: get all current SAPHanaSR values
    # params:  node 
    # global:  sapHanaSr(w)
    # callout: SAPHanaSR-showAttr
    # output:  -
    # rc:      0
    local node="$1"
    if [[ "$node" != "localhost" ]]; then
        mapfile -t sapHanaSr < <(ssh "$node" "SAPHanaSR-showAttr --format=script")
    else
        sapHanaSr=('Site/Mainz/srr="P"')
    fi
    return 0
}

function loadTests() {
    # purpose: get all test definitions in file
    # params:  file 
    # global:  testDefinition(w)
    # callout: python3 querySteps.py
    # output:  -
    # rc:      0
    local file="$1"
    mapfile -t testDefinition < <(python3 querySteps.py < "$file")
    sapHanaSr=( "${sapHanaSr[@]}" "${testDefinition[@]}")
    return 0
}

function search4getValue() {
    # purpose: search in sapHanaSr for pattern and return value(s) 
    # params:  reg Exp
    # global:  sapHanaSr(r)
    # callout: -
    # output:  value(s)
    # if it hits 'Hosts/node02/clone_state="DEMOTED"' it returns "DEMOTED"
    local regExp="$1" s r
    local -a results
    mapfile -t results < <(
            for s in "${sapHanaSr[@]}"; do 
                echo "$s" | awk -F=  '$0 ~ regExp { print $2 }' regExp="$regExp";
            done
        )
    for r in "${results[@]}"; do
        echo "${r//\"/}"
    done
}

function search4getObject() {
    # purpose: search in sapHanaSr for pattern and return objects(s)
    # params:  reg Exp
    # global:  sapHanaSr(r)
    # callout: -
    # output:  value(s)
    # if it hits 'Hosts/node02/clone_state="DEMOTED"' it returns "node02"
    local regExp="$1" s r
    local -a results
    mapfile -t results < <(
            for s in "${sapHanaSr[@]}"; do 
                echo "$s" | awk -F'[/=]'  '$0 ~ regExp { print $2 }' regExp="$regExp";
            done
        )
    for r in "${results[@]}"; do
        echo "${r//\"/}"
    done
}

function search4getKeyValue() {
    # purpose: search in sapHanaSr for pattern and return key-value pairs(s)
    # params:  reg Exp
    # global:  sapHanaSr(r)
    # callout: -
    # output:  value(s)
    # if it hits 'Hosts/node02/clone_state="DEMOTED"' it returns 'clone_state="DEMOTED"'
    local regExp="$1" s r
    local -a results
    mapfile -t results < <(
            for s in "${sapHanaSr[@]}"; do 
                echo "$s" | awk -F'/'  '$0 ~ regExp { print $3 }' regExp="$regExp";
            done
        )
    for r in "${results[@]}"; do
        echo "${r//\"/}"
    done
}

function checkKeyValue() {
        # purpose: search in given array1 for patterns in array2
        # remark keyValues and patterns are both arrays. Each array member MUST be in the form key=value
        # output: failed tests - must ONLY output the failed tests, nothing more!!
        local -a keyValues 
        local -a patterns
        local nowPatterns=1 kV p
        local rc=0
        local -a failedTests
        local purpose
        while [ $# -gt 0 ]; do
            case "$1" in
                --purpose=* ) purpose="${1#*=}";;
                --keyValue ) nowPatterns=1;;
                --pattern ) nowPatterns=0;;
                * ) if [ "$nowPatterns" == 0 ]; then
                        patterns=( "${patterns[@]}" "$1" )
                    else
                        keyValues=( "${keyValues[@]}" "$1" )
                    fi
            esac
            shift
        done
        for p in "${patterns[@]}"; do
            kVFound=2
            # echo "DBG: keyValues: ${keyValues[*]}" >&2
            for kV in "${keyValues[@]}"; do
                # echo "DBG: ?? $kv ~ $p" >&2
                vKey="${kV%=*}"; pKey="${p%=*}"
                if [ "$vKey" == "$pKey" ]; then # if same key, check if we match
                    echo "$kV" | grep -E -q "$p" && kVFound=0 && break || kVFound=1 && break
                fi
            done
            case "$kVFound" in
                0 ) # matching
                    #echo "kV $kV matched by p $p" >&2
                    ;;
                1 ) # not matching
                    failedTests=( "${failedTests[@]}" "$purpose: $kV !~ $p" )
                    if [ "$verbose" == "1" ]; then
                        echo "!!$purpose: $kV !~ $p" >&2
                    fi
                    rc=1
                    ;;
                2)  #  
                    failedTests=( "${failedTests[@]}" "$purpose: missing $p" )
                    if [ "$verbose" == "1" ]; then
                        echo "$purpose: missing $p" >&2
                    fi
                    rc=1
                    ;;
            esac
        done
        if [[ "$rc" == 1 ]]; then 
            echo "${failedTests[@]}"
        fi
        return "$rc"
}

function getAllKeyValue() {
    #
    #
    #
    mapfile -t primarySite   <  <(search4getKeyValue 'Sites/'"$pSite"'/')
    mapfile -t secondarySite <  <(search4getKeyValue 'Sites/'"$sSite"'/')

    mapfile -t primaryHost   <  <(search4getKeyValue 'Hosts/'"$pHost"'/')
    mapfile -t secondaryHost <  <(search4getKeyValue 'Hosts/'"$sHost"'/')
}

function checkAllKeyValueHelp() {
    # output: function must just output output by checkKeyValue ...
    checkKeyValue --purpose=pSite --keyValue "${primarySite[@]}"   --pattern "${patternsPrimarySite[@]}";   
    checkKeyValue --purpose=sSite --keyValue "${secondarySite[@]}" --pattern "${patternsSecondarySite[@]}"; 
    checkKeyValue --purpose=pHost --keyValue "${primaryHost[@]}"   --pattern "${patternsPrimaryHost[@]}";   
    checkKeyValue --purpose=sHost --keyValue "${secondaryHost[@]}" --pattern "${patternsSecondaryHost[@]}";
}

function checkAllKeyValue() {
    # output: all failed tests
    local rc
    local -a failedTests
    mapfile -t failedTests < <( checkAllKeyValueHelp )
    if [[ "${failedTests[*]}" == "" ]]; then
        rc=0
    else
        echo "${failedTests[@]}"
        rc=1
    fi
    return "$rc"
}

function processStep() {
    local stepID="$1"   # full ID (testCase-step)
    local repeat=60
    local interval=2
    local rc
    local postAction
    stepName="$(search4getValue "Steps/$stepID/name")"
    repeat="$(search4getValue "Steps/$stepID/loop")"
    postAction="$(search4getValue "Steps/$stepID/post")"
    #interval="$(search4getValue "Steps/$stepID/wait")"
    if [ "$verbose" == "1" ]; then
        echo "testCase=$testCase, stepID=$stepID, stepName=$stepName, repeat=$repeat theAction=$postAction" >&2
    fi
    mapfile -t patternsPrimarySite < <(search4getKeyValue "Steps/$stepID/pSite" | awk -F= '{ printf "%s=%s\n", $2,$3 }')
    mapfile -t patternsSecondarySite < <(search4getKeyValue "Steps/$stepID/sSite" | awk -F= '{ printf "%s=%s\n", $2,$3 }')
    mapfile -t patternsPrimaryHost < <(search4getKeyValue "Steps/$stepID/pHost" | awk -F= '{ printf "%s=%s\n", $2,$3 }')
    mapfile -t patternsSecondaryHost < <(search4getKeyValue "Steps/$stepID/sHost" | awk -F= '{ printf "%s=%s\n", $2,$3 }')
    loopForStatusJson "$stepID" "$repeat"; rc="$?"
    if [[ "$rc" == 0 && "$postAction" != "" ]]; then
        action "$postAction"
    fi
    return "$rc"
}

function checkPrerequisites() {
    local stepID="$1"   # full ID (testCase-step)
    local rc
    processStep "$stepID"; rc="$?"
    return "$rc"
}

function checkSequence() {
    local testCase="$1"
    local shortStepID="$2"  # short ID step (without testCase)
    local rc
    while [[ "$shortStepID" != "END" ]]; do
        processStep "${testCase}-${shortStepID}"; rc="$?"
        if [[ "$rc" != "0" ]]; then
            message "Step $shortStepID failed"
            break
        fi
        shortStepID="$(search4getValue "Steps/${testCase}-${shortStepID}/next")"
    done
    echo "checkSeqence: rc=$rc"
    return "$rc"
}

function loopForStatusJson() {
    local status="$1"
    local maxLoops="$2"
    local rc=0
    local loops=0
    local lastFailedTests=""
    # TODO PRIO2: get sleep interval by parameter (post)
    if [ "$verbose" == "1" ]; then
        echo "pSite:: ${patternsPrimarySite[*]}" >&2
        echo "sSite:: ${patternsSecondarySite[*]}" >&2
    fi
    while true; do
        (( loops++ ))
        storeSAPHanaSR "$node"
        sapHanaSr=( "${sapHanaSr[@]}" "${testDefinition[@]}")
        getAllKeyValue
        if [ "$verbose" == "1" ]; then
            echo "loops $loops (maxLoops=$maxLoops)" >&2
        else 
            printf "." >&2
        fi
        lastFailedTests="$(checkAllKeyValue)"; rc="$?"
        if [ "$rc" == 0 ]; then
            if [ "$verbose" != "1" ]; then
                printf "\n"  # end the line of dots
            fi
            message "STATUS: REACHED STEP $status ####"
            break
        else
            if [[ "$loops" -ge "$maxLoops"  ]]; then
                if [ "$verbose" != "1" ]; then
                    printf "\n"  # end the line of dots
                fi
                message "RESULT: LAST FAILED COMPARES $lastFailedTests"
                rc=1
                break;
            fi
        fi
        sleep 2
    done
    return "$rc"
}

# TODO: to be implemented in the library and the action to be defined in the json file
function action {
   local theActionCode="$1"
   case "$theActionCode" in
       ksi ) # kill secondary instance 
           local sidadm="ha1adm"
           local node="$sHost"
           local rc=0
           message "ACTION: HDB kill-9 on node $node"
           timeout 10 ssh "$node" 'su - '"$sidadm"' -c "HDB kill-9" 2>/dev/null 1>/dev/null' rc="$?"
           message "ACTION: HDB kill-9 on node $node rc=$rc"
           ;;
       kpi ) # kill primary instance 
           local sidadm="ha1adm"
           local node="$pHost"
           local rc=0
           message "ACTION: HDB kill-9 on node $node"
           timeout 10 ssh "$node" 'su - '"$sidadm"' -c "HDB kill-9" 2>/dev/null 1>/dev/null' rc="$?"
           message "ACTION: HDB kill-9 on node $node rc=$rc"
           ;;
   esac
   return "$rc"
}

