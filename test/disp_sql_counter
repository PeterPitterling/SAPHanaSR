# pylint: disable=invalid-name,fixme,broad-except
"""
# disp_sql_counter
# Authors:      Fabian Herschel, May 2023
# License:      GNU General Public License (GPL)
# Copyright:    (c) 2023 SUSE LLC

CREATE ROW TABLE fhcounter (timestamp TIMESTAMP, counter BIGINT);

TODO: parameter f端r "site" und pro LOOP die site ausgeben
TODO: parameter f端r "user-key"
TODO: parameter f端r "service" und ausgabe pro LOOP Zeile (f端r den Access auf den vom Cluster bereitgestellten Primary)

select * from fhcounter;
"""

# loading classes and libraries
import os
import time
import threading

# pylint: enable=invalid-name
try:
    from hdbcli import dbapi
except ImportError as e:
    print(f"Module dbapi not found - install the missing SAP Python Driver 'hdbcli' - {e}")

# parameter section
FHVERSION = "1.2.20230511.1757"
USERKEY_DFLT = "TESTER"
#


# pylint: disable-next=invalid-name
class DbThreads:
    AccessData = threading.Lock()

    def __init__(self, *args, **kwargs):
        super().__init__()
        #my_sid_upper = os.environ.get('SAPSYSTEMNAME')
        #mysid = my_sid_upper.lower()
        # TODO: user key by option
        self.userkey = USERKEY_DFLT
        self.connection = None
        self.list=[]
        self.count_sql = None
        self.err_status = False
        self.err_txt = ""
        self._err_flag = False
        self.run_time = 0

    def start_threads(self):
        threading.Thread(target=self.run_sql).start()
        threading.Thread(target=self.run_watchdog).start()

    def run_sql(self):
        _connection = self.connect()
        _i = 0
        _count = None
        _list = []
        while True:
            _i += 1
            status = ""
            #print(f"@@RUN-LOOP@@",end='',flush=True)
            self._err_flag = False
            self._err_txt = "<>"
            sleep = 2
            if _connection == None:
                #print(f"@@RUN-CONN@@",end='',flush=True)
                _connection = self.connect()
            else:
                _connection = self.check_and_reconnect(_i)
                #print(f"@@RUN-INS@@",end='',flush=True)
                sql.insert()
                #print(f"@@RUN-CNT@@",end='',flush=True)
                _count = self.count()
                #print(f"@@RUN-SEL@@",end='',flush=True)
                _list = sql.select()
            with DbThreads.AccessData:
                #print(f"@@RUN-DAT@@",end='',flush=True)
                self.count_sql = _count
                self.list = _list[:]
                self.err_status = self._err_flag
                self.err_txt = self._err_txt[:]
                self.run_time = time.time()
            time.sleep(sleep)
        self.disconnect()

    def run_watchdog(self):
        sleep = 6
        while True:
            loop_time = time.time()
            with DbThreads.AccessData:
                time_str = f"{time.strftime('%Y-%m-%d %H:%M:%S')}"
                if (loop_time - self.run_time) > 3*sleep:
                    msg = f"expired data"
                    disconn = True
                else:
                    msg = f"current data"
                    disconn = False
                print(f"WDog {time_str}: {msg}", flush=True)
            if disconn == True:
                self.disconnect()
            time.sleep(sleep)

    def connect(self, **kargs):
        # TODO: key=userkey, table=tablename
        try:
            connection = dbapi.connect(key=self.userkey)
        except Exception as exerr:
            self._err_flag = True
            self._err_txt = "C-ERR-01"
            return None
        if not connection.isconnected():
            self._err_flag = True
            self._err_txt = "C-ERR-02"
            return None
        self.connection = connection
        return connection

    def disconnect(self):
        if self.connection:
            self.connection.close()

    def check_and_reconnect(self, i):
        connection = None
        if not self.connection.isconnected() or i % 100 == 0:
            sql.disconnect()
            connection = sql.connect()
        return connection

    def insert(self):
        count = 1
        time_str = f"{time.strftime('%Y-%m-%d %H:%M:%S')}"
        insert_sql = f"insert into fhcounter (timestamp, counter) VALUES ( '{time_str}', {count} );"

        connection = self.connection
        if connection == None or not connection.isconnected():
            self._err_flag = True
            self._err_txt = "I-ERR-01"
            return(1)
        cursor = connection.cursor()
        try:
            cursor.execute(insert_sql)
        except Exception as exerr:
            self._err_flag = True
            self._err_txt = "I-ERR-02"
        try:
            connection.commit()
        except Exception as exerr:
            self._err_flag = True
            self._err_txt = "I-ERR-03"
        cursor.close()
        return 0

    def count(self, **kargs):
        count_sql = "select count(*) from fhcounter"
        connection = self.connection
        result = None
        if connection == None or not connection.isconnected():
            self._err_flag = True
            self._err_txt = "Q-ERR-01"
            return result

        cursor = connection.cursor()
        try:
            cursor.execute(count_sql)
            for row in cursor:
                result = row[0]
        except Exception as exerr:
            self._err_flag = True
            self._err_txt = "Q-ERR-02"
        cursor.close()
        return result

    def select(self):
        select_sql = "SELECT timestamp, counter FROM fhcounter ORDER BY timestamp, counter"
        connection = self.connection
        result = []
        if connection == None or not connection.isconnected():
            self._err_flag = True
            self._err_txt = "S-ERR-01"
            return None 

        cursor = connection.cursor()
        try:
            cursor.execute(select_sql)
            for row in cursor:
                result.append(row[0])
            result.reverse()
        except Exception as exerr:
            self._err_flag = True
            self._err_txt = "S-ERR-02"
        cursor.close()
        return result 

    def list_last(self, maxnr):
        now = time.time()
        outList = []
        for element in self.list[0:maxnr]:
            etime = element.timestamp()
            dtime = now - etime
            if dtime < 70:
                status = "*"
            else:
                status = "-"
            outList.append(f"{status}")
        outStr = "".join(outList)
        print(f"List: [{outStr}]", end='')
            

sql = DbThreads()
sql.start_threads()

i = 0
print(f"version: {FHVERSION}")
while True:
    i += 1
    status = ""
    sleep = 2
    with DbThreads.AccessData:
        time_str = f"{time.strftime('%Y-%m-%d %H:%M:%S')}"
        print(f"Loop {time_str}: ",end='', flush=True)
        loop_time = time.time()
        if loop_time - sql.run_time > 10:
            msg = f"status=FAIL (EXPIRED)"
        else:
            if sql.err_status == True:
                msg = f"status=FAIL ({sql.err_txt})"
            else:
                msg = f"status=OK"
        print(f"{msg:<22} count={str(sql.count_sql):6} ",end='',flush=True)
        sql.list_last(10)
        print()
    time.sleep(sleep)
sql.disconnect()
