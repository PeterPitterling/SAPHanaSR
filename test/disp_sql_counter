# pylint: disable=invalid-name,fixme,broad-except
"""
# disp_sql_counter
# Authors:      Fabian Herschel, May 2023
# License:      GNU General Public License (GPL)
# Copyright:    (c) 2023 SUSE LLC

CREATE ROW TABLE fhcounter (timestamp TIMESTAMP, counter BIGINT);


select * from fhcounter;
"""

# loading classes and libraries
import os
import time
import threading

# pylint: enable=invalid-name
try:
    from hdbcli import dbapi
except ImportError as e:
    print(f"Module dbapi not found - install the missing SAP Python Driver 'hdbcli' - {e}")

try:
    from hdb_ha_dr.client import HADRBase
except ImportError as e:
    print(f"Module HADRBase not found - running outside of SAP HANA? - {e}")

# parameter section
FHVERSION = "1.2.20230510"
USERKEY_DFLT = "TESTER"
#


# pylint: disable-next=invalid-name
class SqlThread(threading.Thread):
    AccessData = threading.Lock()

    def __init__(self, *args, **kwargs):
        super().__init__()
        #my_sid_upper = os.environ.get('SAPSYSTEMNAME')
        #mysid = my_sid_upper.lower()
        # TODO: user key by option
        self.userkey = USERKEY_DFLT
        self.connection = None
        self.list=[]
        self.count_sql = None

    def run(self):
        _connection = self.connect()
        _i = 0
        while True:
            _i += 1
            status = ""
            sleep = 2
            if _connection == None:
                _connection = self.connect()
                time.sleep(sleep)
                continue
            else:
                _connection = self.check_and_reconnect(_i)
                sql.insert()
                _count = self.count()
                _list = sql.select()
            with SqlThread.AccessData:
                self.count_sql = _count
                self.list = _list[:]
            time.sleep(sleep)
        sql.disconnect()

    def connect(self, **kargs):
        # TODO: key=userkey, table=tablename
        try:
            connection = dbapi.connect(key=self.userkey)
        except Exception as exerr:
            print(f"error during database connection - {exerr}.")
            return None
        if not connection.isconnected():
            print("database connection could not be established")
            return None
        self.connection = connection
        return connection

    def disconnect(self):
        if self.connection:
            self.connection.close()

    def check_and_reconnect(self, i):
        connection = None
        if not self.connection.isconnected() or i % 100 == 0:
            sql.disconnect()
            connection = sql.connect()
        return connection

    def insert(self):
        count = 1
        time_str = f"{time.strftime('%Y-%m-%d %H:%M:%S')}"
        insert_sql = f"insert into fhcounter (timestamp, counter) VALUES ( '{time_str}', {count} );"

        connection = self.connection
        if connection == None or not connection.isconnected():
            #print("insert(): database connection could not be established or disconnected now")
            return(1)
        cursor = connection.cursor()
        try:
            cursor.execute(insert_sql)
        except Exception as exerr:
            pass
            #print("error during execution of the sql statement" f" {insert_sql} - {exerr}.")
        try:
            connection.commit()
        except Exception as exerr:
            pass
            #print("error during commit" f"- {exerr}.")
        cursor.close()
        return 0

    def count(self, **kargs):
        count_sql = "select count(*) from fhcounter"
        connection = self.connection
        result = None
        if connection == None or not connection.isconnected():
            return result

        cursor = connection.cursor()
        try:
            cursor.execute(count_sql)
            for row in cursor:
                result = row[0]
        except Exception as exerr:
            pass
            print("count(): {exerr}", end='')
        cursor.close()
        return result

    def select(self):
        select_sql = "SELECT timestamp, counter FROM fhcounter ORDER BY timestamp, counter"
        connection = self.connection
        result = []
        if connection == None or not connection.isconnected():
            #print("select(): database connection could not be established or disconnected now", end='')
            return None 

        cursor = connection.cursor()
        try:
            cursor.execute(select_sql)
            for row in cursor:
                result.append(row[0])
            result.reverse()
        except Exception as exerr:
            pass
            #print("error during execution of the sql statement" f" {select_sql} - {exerr}.", end='')
        cursor.close()
        return result 

    def list_last(self, maxnr):
        now = time.time()
        outList = []
        for element in self.list[0:maxnr]:
            etime = element.timestamp()
            dtime = now - etime
            if dtime < 10:
                status = "*"
            else:
                status = "-"
            outList.append(f"[{status}]")
        outStr = "".join(outList)
        print(f"List: [{outStr}]", end='')
            

sql = SqlThread()
sql.start()

i = 0
print(f"version: {FHVERSION}")
while True:
    i += 1
    status = ""
    sleep = 2
    time_str = f"{time.strftime('%Y-%m-%d %H:%M:%S')}"
    print(f"Loop {time_str}: ",end='', flush=True)
    #print(f"status 02 {status}: ", end='', flush=True)
    with SqlThread.AccessData:
        if sql.connection == None:
            conStat="nc"
        else:
            conStat="c"
        print(f"conn={conStat} ",end='',flush=True)
        print(f"count={sql.count_sql} ",end='',flush=True)
        sql.list_last(20)
    print()
    time.sleep(sleep)
sql.disconnect()
