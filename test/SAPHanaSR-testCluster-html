#!/usr/bin/python3
"""
 SAPHanaSR-tester-html
 Author:       Fabian Herschel, Jul 2023
 License:      GNU General Public License (GPL)
 Copyright:    (c) 2023 SUSE LLC
 Version:      2023.07.25.14.49
"""

import time
import re
import sys
import json
import argparse
from subprocess import Popen, PIPE
# import random

from paramiko import SSHClient

# TODO: start tasks later from  SAPHanaSR-tester-html
tasks = {
            'SAPHanaSR-tester' : {
                                    'type': 'local',
                                    'command': 'SAPHanaSR-tester --hosts @@HOSTS@@',
                                    'user': 'root',
                                    'repeat': 'no'
                                },
            'db-client' : { # to be started on all hosts in @@HOSTS@@ - alternatively do it on first host and fallback to second, if needed
                            'type': 'remote',
                            'command': 'source ./.bashrc; python disp_sql_counter --userkey=CLUSTER | tee -a /tmp/SAPHanaSR-tester/dbc.log',
                            'user': '@@sidadm@@',
                            'repeat': 'yes',
                            'repeat_delay': '300'
                        }
        }

tiles = {
            'STAT': {
                        'title': 'Statistics',
                        'command': 'statistics',
                        'file': '/tmp/SAPHanaSR-tester/SAPHanaSR-tester.log',
                        'type': 'internal',
                        'user': 'root',
                      },
            'TILE01': {
                        'title': 'Cluster status',
                        'command': 'crm_mon -1r --include none,nodes,resources,failures,failcounts',
                        'type': 'remote',
                        'user': 'root',
                      },
            'TILE02': {
                        'title': 'db-client log',
                        'command': 'tail -15 /tmp/SAPHanaSR-tester/dbc.log',
                        'type': 'remote',
                        'user': 'root',
                      },
            'TILE03': {
                        'title': 'SAP HANA SR Attributes',
                        'command': 'SAPHanaSR-showAttr',
                        'type': 'remote',
                        'user': 'root',
                      },
            'TILE04': {
                        'title': 'SAPHanaSR-tester',
                        'command': 'tail -20 /tmp/SAPHanaSR-tester/SAPHanaSR-tester.log',
                        'type': 'local',
                        'user': 'root',
                      },
        }


class SshMultiNode:

    def message(self, msg, **kwargs):
        """
        message with formatted timestamp
        """
        stdout = True
        if 'stdout' in kwargs:
            stdout = kwargs['stdout']
        # TODO: specify, if message should be written to stdout, stderr and/or log file
        date_time = time.strftime("%Y-%m-%d %H:%M:%S")
        r_id = ""
        msg_arr = msg.split(" ")
        if stdout: 
            print("{}{} {:<9s} {}".format(date_time, r_id, msg_arr[0], " ".join(msg_arr[1:])))


    def __init__(self, **kwargs):
        """
        constructor
        """
        # if 'cmdparse' in kwargs:
        #    cmdparse = kwargs['cmdparse']
        self.config = { 
                        'command': None,
                        'hosts': [],
                        'quiet': True,
                        'report_hostname': True,
                        'sleep': '10',
                        'user': 'root'
                      }
        self.stat = {
                        'all': 0,
                        'succ': 0,
                        'fail': 0,
                        'fail-prereq': 0,
                        'fail-recovery': 0,
                        'fail-any': 0,
                        'succ-any': 0,
                        'succ-prereq': 0,
                        'succ-recovery': 0,
                        'sum-any': 0,
                        'sum-prereq': 0,
                        'sum-recovery': 0,
                    }


    def do_ssh(self, host, user, cmd):
        """
        ssh remote cmd exectution
        returns a tuple ( stdout-string, stderr, string, rc )
        """
        if host:
            try:
                ssh_client = SSHClient()
                ssh_client.load_system_host_keys()
                ssh_client.connect(host, username=user)
                (cmd_stdout, cmd_stderr) = ssh_client.exec_command(cmd)[1:]
                result_stdout = cmd_stdout.read().decode("utf8")
                result_stderr = cmd_stderr.read().decode("utf8")
                result_rc = cmd_stdout.channel.recv_exit_status()
                check_result = (result_stdout, result_stderr, result_rc)
                ssh_client.close()
            except Exception as ssh_muell:
                if test01.config['quiet'] is not True:
                    self.message(f"ssh connection to {host} did not work ...")
                    self.message(f"{type(ssh_muell)}")
                check_result=("", "", 2)
        else:
            check_result=("", "", 2)
        return check_result


    def do_local(self, cmd):
        """
        execute a local command and capture stdout and return code
        """
        result = Popen(cmd.split(), stdout=PIPE, stderr=PIPE)
        stdout, stderr = result.communicate()
        stdout = stdout.decode()
        stderr = stderr.decode()
        return (stdout, stderr, result.returncode)


    def do_internal(self, cmd, file):
        """
        process an program internal action on the given file
        """
        if cmd == "statistics":
            with open(file, "r") as testlogs:
                lines = testlogs.readlines()
            for line in lines:
                if re.search(r"TEST:.*PASSED", line):
                   self.stat['succ'] += 1
                if re.search(r"TEST:.*FAILED", line):
                   self.stat['fail'] += 1
                if re.search(r"STATUS:.*step step10 FAILED", line):
                   self.stat['fail-prereq'] += 1
                if re.search(r"STATUS:.*step step40 FAILED", line):
                   self.stat['fail-recovery'] += 1
                if re.search(r"STATUS:.*step step.* FAILED", line):
                   self.stat['fail-any'] += 1
                if re.search(r"STATUS:.*step step.* passed", line):
                   self.stat['succ-any'] += 1
                if re.search(r"STATUS:.*step step40 passed", line):
                   self.stat['succ-recovery'] += 1
                if re.search(r"STATUS:.*step step10 passed", line):
                   self.stat['succ-prereq'] += 1
            self.stat['all'] = self.stat['succ'] + self.stat['fail']
            self.stat['sum-any'] = self.stat['succ-any'] + self.stat['fail-any']
            self.stat['sum-prereq'] = self.stat['succ-prereq'] + self.stat['fail-prereq']
            self.stat['sum-recovery'] = self.stat['succ-recovery'] + self.stat['fail-recovery']
            

test01 = SshMultiNode()
parser = argparse.ArgumentParser()
parser.add_argument("--hosts", nargs="*", help="hosts to connect to (stops after first successful command)")
parser.add_argument("--user", help="linux user to be used for ssh connection (default is root)")
args = parser.parse_args()
if args.hosts:
    test01.config['hosts'] = args.hosts
if args.user:
    test01.config['user'] = args.user

date_time = time.strftime("%Y-%m-%d %H:%M:%S")
seconds = int(time.time())

test_scenario = "SAPHanaSR-angi - ScaleUp"
# html_out: use this as output-path later once SAPHanaSR-tester-html runs more out of its own (not in a bash script loop)
html_out = 'TestSAPHanaSR-angi-ScaleOut.html'

# simulate changing test numbers
test_succ = seconds - 1689000000
test_fail_prereq = int( seconds / 100 )  - 16890809
test_fail_recovery = int( seconds / 1000 )  - 1689088

test_fail = test_fail_prereq + test_fail_recovery
test_sum = test_succ + test_fail

test_file_in="testgrid.html.in"

"""
with open("/etc/apt/sources.list", "r") as sources:
    lines = sources.readlines()
"""

while True:
    with open("testgrid.html.in", "r") as sources:
        lines = sources.readlines()
    with open(f"{html_out}.out", "w") as sources:
        for tk in tiles:
            the_tile = tiles[tk]
            title = the_tile['title']
            command = the_tile['command']
            user = the_tile['user']
            cmd_type = the_tile['type']
            the_tile['content'] = ""
            tile_time_pre = int(time.time())
            print(f"tile tile={tk} title={title} command={command} type={cmd_type}") 
            if cmd_type == "remote":
                for host in test01.config['hosts']:
                    #result = test01.do_ssh(host, the_tile['user'], the_tile['command'])
                    (stdout, stderr, rc) = test01.do_ssh(host, the_tile['user'], the_tile['command'])
                    #if result[2] > 0:
                    if rc > 0:
                        if True:
                            test01.message(f"INFO: Connection to {host} failed rc={rc}") 
                    else:
                        the_tile['content'] = stdout
                        break # only take the first host which answers with rc == 0
            elif cmd_type == "local":
                #result = Popen(["df", "-hP"], stdout=PIPE, stderr=PIPE)
                #stdout, stderr = result.communicate()
                (stdout, stderr, rc) = test01.do_local(the_tile['command'])
                the_tile['content'] = stdout
            else: # currently this means 'internal'
                test01.do_internal(the_tile['command'], the_tile['file'])
                pass
            tile_time_post = int(time.time())
            print(f"tile tile={tk} title={title} command={command} type={cmd_type} runtime={tile_time_post-tile_time_pre}") 
            regexp_title = f"@@{tk}_TITLE@@"
            regexp_content = f"@@{tk}_CONTENT@@"
            line_index = 0
            for line in lines:
                line = re.sub(r"{}".format(regexp_title), f"{the_tile['title']} - {date_time}", line)
                line = re.sub(r"{}".format(regexp_content), the_tile['content'], line)
                lines[line_index] = line
                line_index += 1
        for line in lines:
            line = re.sub(r"@@TEST_SCENARIO@@", test_scenario, line)
            line = re.sub(r"@@TEST_SUCC@@", str(test01.stat['succ']), line)
            line = re.sub(r"@@TEST_FAIL@@", str(test01.stat['fail']), line)
            line = re.sub(r"@@TEST_SUM@@", str(test01.stat['all']), line)
            line = re.sub(r"@@TEST_FAIL_PREREQ@@", str(test01.stat['fail-prereq']), line)
            line = re.sub(r"@@TEST_FAIL_RECOVERY@@", str(test01.stat['fail-recovery']), line)
            line = re.sub(r"@@TEST_FAIL_ANY@@", str(test01.stat['fail-any']), line)
            line = re.sub(r"@@TEST_SUCC_ANY@@", str(test01.stat['succ-any']), line)
            line = re.sub(r"@@TEST_SUCC_RECOVERY@@", str(test01.stat['succ-recovery']), line)
            line = re.sub(r"@@TEST_SUCC_PREREQ@@", str(test01.stat['succ-prereq']), line)
            line = re.sub(r"@@TEST_SUM_ANY@@", str(test01.stat['sum-any']), line)
            line = re.sub(r"@@TEST_SUM_RECOVERY@@", str(test01.stat['sum-recovery']), line)
            line = re.sub(r"@@TEST_SUM_PREREQ@@", str(test01.stat['sum-prereq']), line)
            sources.write(line)

    print(f"mv {html_out}.out /srv/www/htdocs/{html_out}")
    test01.do_local(f"mv {html_out}.out /srv/www/htdocs/{html_out}")
    time.sleep(int(test01.config['sleep']))
